MACRO_CLEAR_PLAYER MACRO X,Y

						mov pre_position_x,x
						mov pre_position_y,y
						call Update_Players
ENDM

; MACRO_CLEAR_Barrier MACRO X,Y

; 						mov pre_position_x,x
; 						mov pre_position_y,y
; 						call Update_Players
; ENDM
PRINT_Messages MACRO MSG
                        PUSH AX
                        push DX
					    mov ah, 9
                        mov dx, offset MSG
                        int 21h 
                        pop DX
                        POP AX
ENDM
;;;;Macro to send a 8 bit word using uart
SendChar MACRO MyChar
    LOCAL Send
    Send:
       mov         dx, 3fdh

		in          al, dx
		test        al, 00100000b
		jz          Send 
		mov         dx, 3f8h ;sending value
		mov         al, MyChar
		out         dx, al
ENDM 
;;;;Macro to recieve a 8 bit word using uart
ReceiveChar MACRO
    LOCAL Return
	RETURN:
    MOV AL, 0
     mov         dx , 3FDH              	; Line Status Register
	in          al , dx
	test        al , 1
	JZ          RETURN
	mov         dx , 03F8H
	in          al , dx

ENDM 
;;;;Macro to recieve a 8 bit word using uart
ReceiveCharNotAmustToRecieve MACRO
    LOCAL Return
    MOV AL, 0
     mov         dx , 3FDH              	; Line Status Register
	in          al , dx
	test        al , 1
	JZ          RETURN
	mov         dx , 03F8H
	in          al , dx
	RETURN:
ENDM
.model HUGE

.stack 64h

.data
	WINDOW_WIDTH        equ 320                              ;the width of the Game window (320 pixels)
	WINDOW_HEIGHT       equ 160                              ;the height of the Game window (200*4/5 pixels)---> the chat takes 1/5 of the console
	WINDOW_BOUNDS       equ 6                                ; used to check collisions early from the lower,left,right pounds
	window_bounds_upper equ 15								 ;height of the health bar
	health_bar_width    equ 100                              ;width of each player's health bar
	heart_height        equ 10                               ;height of the heart image in health bar
	heart_width         equ 15                               ;height of the heart image in health bar
	TIME_AUX            DB  0                                ;variable used when checking if the time has changed
	
	background_color    EQU 53                               ;Background pixel color id
	graphics_mode       EQU 13h                              ;320*200 pixels , 256colors

	PRE_POSITION_X       DW  0								 ;Temp variable used when moving position to check first if it causes collisions
	PRE_POSITION_Y      DW  0								 ;Temp variable used when moving position to check first if it causes collisions
	PRE_POSITION_X2       DW  0								 ;Temp variable used when moving position to check first if it causes collisions
	PRE_POSITION_Y2      DW  0								 ;Temp variable used when moving position to check first if it causes collisions
 First_Player_Name  DB 15,?,15 dup('$')
	first_player_X      DW  50								 ;The starting X-position of player one
	first_player_Y      DW  50								 ;The starting Y-position of player one
	first_player_health DW  5                                 ;Number of hearts to the first player
	first_player_health_X equ 0								 ;the starting upper left x coordinate of the first player's first heart
	first_player_health_Y equ 0								 ;the starting upper left y coordinate of the first player's first heart
	first_player_health_immunity DW 0						 ;when the player gets hit by barrier, he gains an immunity to resist the barriers
	first_player_Freeze DW 0								 ;Duration for which the player is frozen
    First_Is_Collided DB 0                                   ;Boolean Variable To check if the player is colliding
    Second_Player_Name  DB 15,?,15 dup('$')
	second_player_X     DW  270								 ;The starting X-position of player two
	SECOND_PLAYER_Y     DW  50								 ;The starting Y-position of player two
	second_player_health DW 5                                ;Number of hearts to the second player
    second_player_health_X equ 305							 ;the starting upper left x coordinate of the second player's first heart
	second_player_health_Y equ 0							 ;the starting upper left y coordinate of the second player's first heart
	second_player_health_immunity DW 0						 ;when the player gets hit by barrier, he gains an immunity to resist the barriers
	second_player_Freeze DW 0								 ;Duration for which the player is frozen

	PLAYERS_WIDTH       equ  20								 ;the width of player's image
	PLAYERS_HEIGHT      equ  25								 ;the height of player's image
	PLAYERS_VELOCITY    DW  04h
    Second_Is_Collided DB 0                                ;Boolean Variable To check if the player is colliding
	Initial_Freeze EQU 20                                  ;The freezing time of player after being attacked
	
    Initial_Imunity EQU 20                                 ;This is the immunity to the player fter being hit
	;VARIABLES USED IN THE PROCS OF DRAWING THE BARRIER
	LEN       	 DW  100d									 ;used by the draw barrier proc
	WID          DW  100d									 ;used by the draw barrier proc
	LENMAX       DW  252d									 ;used by the draw barrier proc
	WIDMAX       DW  152d									 ;used by the draw barrier proc
	Initial_Y_Barrier1   EQU 140
	Initial_Y_Barrier2 EQU 140
	X_BARRIER1   DW  10									 	 ; xpos of barrier1
	Y_BARRIER1   DW  140  									 ; ypos of barrier1

	X_BARRIER2   DW  260 									 ; xpos of barrier2
	Y_BARRIER2   DW  104									 ; ypos of barrier2


	
	;Laser Colors
	RED EQU 39
	Yellow EQU 14
	Dark_Blue EQU 105
	Light_Blue EQU 76


	;Laser Target (The ARC Reactor of the suit)
	Player_Reactor_Y_Offset EQU 16
	Player_Reactor_Y_Size EQU 4
	LASER_SIZE EQU 3


	;Laser Launcher (Laser Shooters)
	Player_Shooter_Y_Offset EQU 19

	;Lasers Coordinates
	Blue_Laser_Start_X DW ?
	Blue_Laser_End_X DW ?
	
	Red_Laser_Start_X DW ?
	Red_Laser_End_X DW ?



	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


	;#DEFINES FOR THE LENGTH AND SIZE OF THE BARRIER
	BARRIER_HORIZONTAL_SIZE  EQU 60D
	BARRIER_VERTICAL_SIZE  EQU 10D
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	;;SCREEN SIZE IN PIXELS
	SCREEN_MAX_X EQU 319D
	SCREEN_MAX_Y EQU 199D


  

	;next is the first player's pixel colors/Note: they are indexed in reversed order (from the (20,25) to (0,0))
	p1                  DB  0, 0, 0, 16, 16, 16, 16, 16, 0, 0, 0, 0, 16, 16, 16, 16, 16, 0, 0, 0, 0, 0, 0, 16, 39, 39, 39, 16, 0, 0, 0, 0, 16, 39, 39, 39, 16, 0, 0, 0
	                    DB  0, 0, 0, 16, 16, 39, 39, 16, 0, 0, 0, 0, 16, 39, 39, 16, 16, 0, 0, 0, 0, 0, 0, 0, 16, 39, 14, 14, 16, 16, 16, 16, 14, 14, 39, 16, 0, 0, 0, 0
	                    DB  0, 0, 0, 31, 16, 14, 14, 39, 39, 39, 39, 39, 39, 14, 14, 16, 31, 0, 0, 0, 0, 0, 16, 16, 0, 16, 39, 39, 39, 39, 39, 39, 39, 39, 16, 0, 16, 16, 0, 0
	                    DB  0, 16, 39, 39, 16, 16, 39, 39, 39, 16, 16, 39, 39, 39, 16, 16, 39, 39, 16, 0, 0, 16, 39, 39, 14, 16, 39, 39, 16, 25, 25, 16, 39, 39, 16, 14, 39, 39, 16, 0
	                    DB  0, 0, 16, 14, 14, 16, 39, 16, 25, 25, 25, 25, 16, 39, 16, 14, 14, 16, 0, 0, 0, 0, 41, 16, 39, 16, 39, 16, 16, 16, 16, 16, 16, 39, 16, 39, 16, 41, 0, 0
	                    DB  0, 0, 41, 0, 16, 39, 16, 14, 14, 14, 14, 14, 14, 16, 39, 16, 0, 41, 0, 0, 0, 41, 41, 0, 0, 16, 14, 16, 16, 16, 16, 16, 16, 14, 16, 0, 0, 41, 41, 0
	                    DB  0, 41, 0, 0, 16, 39, 14, 14, 14, 14, 14, 14, 14, 14, 39, 16, 0, 0, 41, 0, 0, 41, 0, 16, 39, 39, 14, 14, 14, 14, 14, 14, 14, 14, 39, 39, 16, 0, 41, 0
	                    DB  41, 41, 16, 39, 14, 25, 25, 25, 16, 16, 16, 16, 25, 25, 25, 14, 39, 16, 41, 41, 41, 0, 16, 39, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 39, 16, 0, 41
	                    DB  41, 0, 16, 39, 16, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 16, 39, 16, 0, 41, 41, 0, 0, 16, 39, 14, 14, 14, 39, 39, 39, 39, 14, 14, 14, 39, 16, 0, 0, 41
	                    DB  41, 0, 0, 16, 39, 14, 14, 39, 39, 39, 39, 39, 39, 14, 14, 39, 16, 0, 0, 41, 41, 0, 0, 0, 16, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 16, 0, 0, 0, 41
	                    DB  41, 41, 41, 41, 41, 16, 16, 16, 39, 39, 39, 39, 16, 16, 16, 41, 41, 41, 41, 41, 41, 14, 14, 14, 14, 14, 14, 14, 16, 16, 16, 16, 14, 14, 14, 14, 14, 14, 14, 41
	                    DB  41, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 41, 41, 41, 41, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 41, 41, 41
	                    DB  41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41






	;next is the first player's heart pixel colors/Note: they are indexed in reversed order'
	h1 				   DB 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 39, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 39, 39, 39, 16 
 					   DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 39, 39, 39, 39, 39, 16, 0, 0, 0, 0, 0, 0, 0, 16, 39, 39, 39, 39, 39, 39, 39, 16, 0, 0, 0, 0, 0, 16, 39, 39 
 					   DB 39, 39, 39, 39, 39, 39, 39, 16, 0, 0, 0, 0, 16, 39, 39, 39, 39, 16, 39, 39, 39, 39, 16, 0, 0, 0, 0, 0, 16, 39, 39, 16, 0, 16, 39, 39, 16, 0, 0, 0 
 					   DB 0, 0, 0, 0, 16, 16, 0, 0, 0, 16, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 	;next is the Second player's pixel colors/Note: they are indexed in reversed order (from the (20,25) to (0,0))
	p2                  DB  0, 0, 0, 16, 16, 16, 16, 16, 0, 0, 0, 0, 16, 16, 16, 16, 16, 0, 0, 0, 0, 0, 0, 16, 105, 105, 105, 16, 0, 0, 0, 0, 16, 105, 105, 105, 16, 0, 0, 0
	                    DB  0, 0, 0, 16, 16, 105, 105, 16, 0, 0, 0, 0, 16, 105, 105, 16, 16, 0, 0, 0, 0, 0, 0, 0, 16, 105, 76, 76, 16, 16, 16, 16, 76, 76, 105, 16, 0, 0, 0, 0
	                    DB  0, 0, 0, 31, 16, 76, 76, 105, 105, 105, 105, 105, 105, 76, 76, 16, 31, 0, 0, 0, 0, 0, 16, 16, 0, 16, 105, 105, 105, 105, 105, 105, 105, 105, 16, 0, 16, 16, 0, 0
	                    DB  0, 16, 105, 105, 16, 16, 105, 105, 105, 16, 16, 105, 105, 105, 16, 16, 105, 105, 16, 0, 0, 16, 105, 105, 76, 16, 105, 105, 16, 25, 25, 16, 105, 105, 16, 76, 105, 105, 16, 0
	                    DB  0, 0, 16, 76, 76, 16, 105, 16, 25, 25, 25, 25, 16, 105, 16, 76, 76, 16, 0, 0, 0, 0, 105, 16, 105, 16, 105, 16, 16, 16, 16, 16, 16, 105, 16, 105, 16, 105, 0, 0
	                    DB  0, 0, 105, 0, 16, 105, 16, 76, 76, 76, 76, 76, 76, 16, 105, 16, 0, 105, 0, 0, 0, 105, 105, 0, 0, 16, 76, 16, 16, 16, 16, 16, 16, 76, 16, 0, 0, 105, 105, 0
	                    DB  0, 105, 0, 0, 16, 105, 76, 76, 76, 76, 76, 76, 76, 76, 105, 16, 0, 0, 105, 0, 0, 105, 0, 16, 105, 105, 76, 76, 76, 76, 76, 76, 76, 76, 105, 105, 16, 0, 105, 0
	                    DB  105, 105, 16, 105, 76, 25, 25, 25, 16, 16, 16, 16, 25, 25, 25, 76, 105, 16, 105, 105, 105, 0, 16, 105, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 105, 16, 0, 105
	                    DB  105, 0, 16, 105, 16, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 16, 105, 16, 0, 105, 105, 0, 0, 16, 105, 76, 76, 76, 105, 105, 105, 105, 76, 76, 76, 105, 16, 0, 0, 105
	                    DB  105, 0, 0, 16, 105, 76, 76, 105, 105, 105, 105, 105, 105, 76, 76, 105, 16, 0, 0, 105, 105, 0, 0, 0, 16, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 16, 0, 0, 0, 105
	                    DB  105, 105, 105, 105, 105, 16, 16, 16, 105, 105, 105, 105, 16, 16, 16, 105, 105, 105, 105, 105, 105, 76, 76, 76, 76, 76, 76, 76, 16, 16, 16, 16, 76, 76, 76, 76, 76, 76, 76, 105
	                    DB  105, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 105, 105, 105, 105, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 105, 105, 105
        				DB 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105, 105


	;next is the second player's heart pixel colors/Note: they are indexed in reversed order'
	h2 					DB 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 105, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 105, 105, 105, 16 
 						DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 105, 105, 105, 105, 105, 16, 0, 0, 0, 0, 0, 0, 0, 16, 105, 105, 105, 105, 105, 105, 105, 16, 0, 0, 0, 0, 0, 16, 105, 105 
 						DB 105, 105, 105, 105, 105, 105, 105, 16, 0, 0, 0, 0, 16, 105, 105, 105, 105, 16, 105, 105, 105, 105, 16, 0, 0, 0, 0, 0, 16, 105, 105, 16, 0, 16, 105, 105, 16, 0, 0, 0 
 						DB 0, 0, 0, 0, 16, 16, 0, 0, 0, 16, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0




	Barrier_array	 	DB 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 16, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186
 					    DB 186, 16, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186
 						DB 186, 186, 16, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 16, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186
 						DB 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 16, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186
 						DB 186, 16, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 186, 186, 186, 186, 186, 186, 186
 						DB 186, 186, 16, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 16, 186, 186, 186, 186, 186, 186, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
 						DB 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 16, 186, 186, 186, 186, 186, 186, 186, 186, 186, 16, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186
 						DB 186, 16, 186, 186, 186, 186, 186, 186, 16, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 16, 186, 186, 186, 186, 186, 186, 186
 						DB 186, 186, 16, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 16, 186, 186, 186, 186, 186, 186, 16, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186
 						DB 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
 						DB 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 186, 186, 186, 186, 186, 186, 186, 186, 16, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186
 						DB 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 16, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186
 						DB 186, 186, 186, 186, 186, 186, 186, 186, 16, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 16, 186, 186, 186, 186
 						DB 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 16, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186
 						DB 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 16, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186, 186 

    ;MAIN MENU
	GAME_MASTER DB 00H
	GAME_SLAVE DB 0
	CHAT_MASTER DB 0
	CHAT_SLAVE DB 0
	LEVEL_CHOSEN DB 0
	GAME_INVITATION_SEND_MSG DB 'YOU SENT A GAME INVITATION TO $' 
	GAME_INVITATION_REC_MSG DB ' sent A GAME INVITATION TO YOU  $'
	CHAT_INVITATION_SEND_MEG DB 'YOU SENT A CHAT INVITATION TO $' 
	CHAT_INVITATION_REC_MEG  DB ' sent A CHAT INVITATION TO YOU  $'
	play_against_meg       db "you are playing against $"
	WAITING_MESSAGE DB 'PLEASE WAIT FOR OTHER PLAYER RESPONSE $'
    CHAT DB '*To Start Chatting Press F1 $'
    Sky_GAME DB '*To Start Sky Fall Game Press F2 $'
    END_GAME_mess DB '*To End the Program Press ESC $'
    levelone DB  '*please press 1 for level 1 $'
    leveltwo DB  '*please press 2 for level 2 $'
    Name_Message_1 DB '*Enter the first player name,Press Enter to porceed $'
    Name_Message_2 DB '*Enter the second player name, Press Enter to porceed $'
    Invalid_Start_msg2 db "* Invalid Player Name ! $"
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Game over screen;;;;;;;;;;;;;;;;;;;;;;;;;;;
imgW equ 200
imgH equ 26
img DB 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 112, 112, 112, 112, 112, 112, 112, 112, 184, 184, 16, 16, 16, 16, 184, 183, 112, 112, 112, 112, 112, 184, 16, 184, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112, 112 
 DB 112, 112, 112, 112, 183, 184, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 184, 183, 184, 184, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 183, 183, 112, 112, 112, 184 
 DB 184, 184, 112, 112, 112, 112, 112, 112, 112, 185, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 184, 112, 112, 112, 112, 112, 112, 112, 112, 112, 184, 112, 112, 112 
 DB 184, 184, 112, 112, 112, 112, 112, 112, 16, 16, 184, 112, 112, 112, 112, 112, 184, 16, 16, 16, 16, 16, 16, 16, 16, 184, 112, 112, 184, 184, 112, 112, 16, 16, 184, 112, 112, 112, 112, 112 
 DB 183, 16, 16, 16, 16, 16, 16, 16, 16, 184, 184, 112, 112, 112, 112, 184, 16, 16, 184, 112, 112, 112, 184, 112, 184, 184, 112, 112, 112, 112, 112, 112, 184, 184, 16, 16, 16, 16, 16, 16 
 DB 113, 113, 111, 111, 111, 111, 111, 111, 136, 184, 16, 16, 16, 16, 184, 207, 136, 111, 111, 111, 111, 183, 185, 209, 111, 111, 111, 111, 111, 111, 111, 111, 113, 113, 111, 111, 113, 113, 113, 113 
 DB 111, 111, 111, 111, 208, 184, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 183, 207, 113, 113, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 208, 136, 113, 113, 111, 111 
 DB 113, 111, 113, 113, 113, 111, 113, 113, 111, 208, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 208, 111, 111, 111, 111, 113, 111, 111, 111, 111, 111, 111, 111, 111 
 DB 111, 136, 111, 111, 111, 111, 111, 111, 16, 16, 111, 111, 111, 111, 111, 111, 183, 16, 16, 16, 16, 16, 16, 16, 16, 183, 111, 111, 111, 111, 111, 111, 16, 16, 111, 111, 113, 113, 111, 110 
 DB 182, 16, 16, 16, 16, 16, 16, 16, 16, 185, 113, 111, 111, 111, 111, 111, 16, 185, 208, 111, 111, 111, 113, 113, 113, 113, 111, 111, 113, 113, 113, 113, 113, 185, 16, 16, 16, 16, 16, 16 
 DB 113, 113, 4, 4, 4, 4, 4, 4, 4, 184, 184, 16, 16, 16, 184, 111, 4, 4, 4, 4, 4, 4, 184, 208, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 
 DB 4, 4, 40, 40, 4, 184, 16, 16, 16, 16, 16, 16, 16, 16, 16, 184, 112, 4, 4, 4, 184, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 184, 112, 4, 4, 4, 4, 4 
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 111, 184, 184, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 184, 111, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 
 DB 4, 4, 4, 4, 4, 4, 4, 4, 184, 184, 112, 4, 4, 4, 4, 4, 185, 16, 16, 16, 16, 16, 16, 16, 16, 184, 4, 4, 4, 4, 4, 4, 184, 183, 4, 4, 4, 4, 4, 4 
 DB 185, 16, 16, 16, 16, 16, 16, 16, 16, 208, 4, 4, 4, 4, 4, 111, 184, 183, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 112, 184, 16, 16, 16, 16, 16 
 DB 113, 113, 4, 4, 4, 4, 4, 4, 4, 112, 183, 18, 16, 16, 184, 111, 4, 4, 40, 4, 4, 4, 184, 208, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 
 DB 4, 4, 40, 40, 4, 184, 16, 16, 16, 16, 16, 16, 16, 16, 16, 184, 112, 4, 4, 4, 183, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 184, 184, 113, 4, 4, 4, 4, 4 
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 111, 184, 184, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 184, 111, 111, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 
 DB 4, 4, 4, 4, 4, 4, 4, 4, 184, 184, 112, 4, 4, 4, 4, 4, 185, 16, 16, 16, 16, 16, 16, 16, 16, 184, 4, 4, 4, 4, 4, 4, 183, 183, 4, 4, 4, 4, 4, 4 
 DB 112, 16, 16, 16, 16, 16, 16, 16, 16, 208, 4, 4, 4, 4, 4, 111, 183, 183, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 112, 184, 183, 16, 16, 16, 16 
 DB 16, 16, 112, 4, 40, 40, 4, 40, 4, 4, 4, 4, 183, 184, 184, 113, 4, 40, 40, 40, 4, 112, 16, 16, 16, 16, 16, 16, 183, 183, 16, 185, 184, 184, 16, 16, 16, 184, 112, 4 
 DB 4, 4, 40, 40, 4, 184, 16, 16, 16, 16, 16, 16, 16, 185, 113, 4, 4, 4, 4, 4, 4, 4, 111, 184, 16, 16, 16, 16, 16, 16, 16, 185, 4, 4, 40, 40, 4, 4, 184, 16 
 DB 16, 16, 185, 185, 16, 16, 112, 4, 40, 4, 4, 4, 111, 184, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 183, 183, 183, 185, 16, 16, 16, 16, 183, 183, 183, 16, 16, 16 
 DB 184, 111, 4, 4, 4, 40, 40, 4, 16, 16, 4, 4, 4, 40, 4, 4, 182, 16, 16, 16, 16, 16, 16, 16, 16, 112, 4, 4, 40, 40, 4, 4, 184, 16, 4, 40, 40, 40, 40, 4 
 DB 112, 16, 16, 16, 16, 16, 16, 16, 16, 185, 40, 40, 40, 40, 4, 4, 16, 184, 4, 4, 4, 40, 4, 4, 111, 184, 185, 185, 185, 185, 4, 4, 4, 4, 4, 4, 183, 16, 16, 16 
 DB 16, 16, 112, 4, 40, 4, 4, 4, 40, 40, 39, 4, 183, 184, 184, 113, 40, 40, 40, 40, 4, 112, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 184, 112, 4 
 DB 4, 40, 40, 40, 4, 184, 16, 16, 16, 16, 16, 16, 16, 185, 113, 4, 4, 4, 4, 40, 4, 4, 111, 184, 16, 16, 16, 16, 16, 16, 16, 113, 4, 4, 40, 40, 4, 4, 184, 16 
 DB 16, 16, 16, 16, 16, 16, 112, 4, 40, 40, 4, 4, 136, 185, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 184, 112, 4, 40, 40, 4, 4, 4, 16, 16, 4, 4, 40, 4, 4, 4, 208, 16, 16, 16, 16, 16, 16, 16, 16, 112, 4, 40, 40, 40, 4, 4, 184, 184, 4, 40, 40, 40, 40, 4 
 DB 112, 16, 16, 16, 16, 16, 16, 16, 16, 185, 40, 40, 40, 40, 4, 4, 16, 16, 4, 4, 4, 40, 4, 4, 112, 184, 16, 16, 16, 184, 4, 4, 4, 4, 4, 4, 208, 16, 16, 16 
 DB 16, 16, 183, 136, 136, 4, 40, 40, 40, 40, 40, 4, 112, 112, 112, 4, 40, 40, 40, 40, 39, 111, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 112, 4 
 DB 40, 40, 40, 40, 4, 112, 16, 16, 16, 16, 184, 184, 112, 4, 40, 40, 40, 40, 40, 40, 40, 40, 4, 112, 184, 184, 16, 16, 16, 16, 16, 111, 40, 40, 40, 40, 40, 4, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 184, 4, 40, 40, 40, 40, 4, 184, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 16, 185, 4, 40, 40, 40, 40, 4, 184, 184, 4, 40, 40, 40, 40, 4, 208, 16, 184, 184, 184, 112, 183, 184, 184, 185, 40, 40, 40, 40, 40, 4, 184, 184, 4, 40, 40, 40, 40, 40 
 DB 4, 112, 112, 112, 112, 112, 112, 112, 112, 4, 40, 40, 40, 40, 40, 4, 184, 184, 4, 40, 40, 40, 40, 40, 182, 16, 16, 16, 16, 16, 113, 111, 4, 4, 40, 40, 4, 112, 184, 184 
 DB 16, 16, 184, 184, 184, 112, 40, 40, 40, 40, 40, 40, 113, 113, 4, 4, 40, 40, 40, 40, 39, 111, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 112, 4 
 DB 40, 40, 40, 40, 4, 112, 16, 16, 16, 16, 208, 136, 4, 4, 40, 40, 40, 40, 40, 40, 40, 40, 40, 4, 136, 136, 16, 16, 16, 16, 16, 111, 40, 40, 40, 40, 40, 4, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 184, 4, 40, 40, 40, 40, 4, 184, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 16, 185, 4, 40, 40, 40, 40, 4, 184, 184, 4, 40, 40, 40, 40, 40, 208, 16, 16, 208, 136, 136, 207, 16, 184, 113, 40, 40, 40, 40, 40, 4, 184, 184, 4, 40, 40, 40, 40, 40 
 DB 4, 4, 4, 4, 111, 111, 136, 136, 4, 4, 40, 40, 40, 40, 40, 4, 184, 184, 4, 40, 40, 40, 40, 39, 182, 16, 16, 16, 16, 16, 184, 112, 112, 4, 40, 40, 4, 113, 113, 113 
 DB 16, 16, 16, 16, 16, 185, 4, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 184, 4 
 DB 40, 40, 40, 40, 4, 111, 16, 16, 16, 184, 112, 41, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 4, 184, 16, 16, 16, 184, 110, 40, 40, 40, 40, 4, 4, 184, 16 
 DB 16, 16, 16, 16, 16, 16, 184, 4, 40, 40, 40, 40, 4, 112, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 184, 112, 40, 40, 40, 40, 40, 4, 182, 183, 4, 40, 40, 40, 40, 40, 185, 184, 184, 112, 40, 40, 111, 184, 184, 113, 40, 40, 40, 40, 40, 4, 185, 184, 4, 4, 40, 40, 40, 40 
 DB 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 4, 184, 183, 4, 40, 40, 40, 40, 40, 208, 184, 184, 184, 16, 16, 16, 16, 184, 111, 40, 40, 40, 40, 40, 4 
 DB 16, 16, 16, 16, 16, 185, 4, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 39, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 185, 4 
 DB 40, 40, 40, 40, 4, 112, 16, 18, 16, 16, 112, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 4, 185, 16, 18, 16, 184, 110, 40, 40, 40, 40, 40, 4, 184, 16 
 DB 16, 16, 16, 16, 16, 16, 184, 6, 40, 40, 40, 40, 4, 184, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 184, 112, 40, 40, 40, 40, 40, 4, 183, 183, 4, 40, 40, 40, 40, 40, 113, 184, 184, 111, 40, 40, 111, 184, 184, 113, 40, 40, 40, 40, 40, 4, 184, 184, 4, 40, 40, 40, 40, 40 
 DB 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 4, 184, 184, 4, 40, 40, 40, 40, 40, 185, 184, 184, 184, 16, 16, 16, 16, 16, 111, 40, 40, 40, 40, 40, 4 
 DB 6, 6, 6, 6, 6, 6, 42, 42, 6, 113, 186, 209, 207, 206, 113, 6, 42, 42, 42, 41, 12, 114, 16, 16, 16, 16, 16, 16, 16, 114, 140, 6, 6, 6, 6, 6, 6, 6, 42, 42 
 DB 42, 42, 42, 42, 140, 186, 184, 212, 140, 6, 42, 42, 42, 42, 42, 42, 6, 113, 185, 113, 6, 42, 42, 42, 42, 42, 6, 6, 163, 185, 16, 188, 42, 41, 42, 42, 42, 6, 184, 16 
 DB 16, 16, 16, 16, 16, 16, 185, 12, 41, 42, 42, 42, 12, 185, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 115, 140, 6, 6, 6, 6, 6, 6 
 DB 6, 42, 42, 42, 42, 42, 42, 6, 16, 16, 6, 42, 42, 42, 42, 42, 42, 42, 6, 42, 42, 42, 42, 42, 6, 42, 42, 42, 42, 41, 42, 6, 185, 184, 6, 42, 42, 42, 42, 42 
 DB 114, 185, 111, 183, 208, 208, 185, 185, 184, 114, 12, 42, 42, 42, 42, 6, 16, 16, 12, 42, 42, 42, 42, 42, 6, 6, 6, 186, 16, 16, 16, 16, 16, 137, 42, 42, 42, 42, 42, 6 
 DB 65, 42, 42, 42, 65, 42, 42, 42, 12, 112, 16, 184, 184, 184, 184, 139, 42, 42, 42, 42, 12, 6, 16, 16, 16, 16, 16, 16, 16, 136, 65, 42, 42, 42, 42, 12, 65, 42, 42, 42 
 DB 42, 42, 42, 42, 12, 113, 16, 138, 65, 42, 42, 42, 42, 42, 42, 42, 12, 184, 184, 185, 12, 42, 42, 42, 42, 42, 42, 65, 64, 185, 16, 139, 42, 42, 42, 42, 12, 6, 184, 16 
 DB 16, 16, 16, 16, 16, 16, 185, 64, 42, 42, 42, 42, 12, 185, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 184, 139, 65, 65, 42, 42, 42, 42, 42 
 DB 42, 42, 42, 42, 42, 42, 42, 12, 16, 16, 12, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 65, 42, 42, 42, 42, 42, 42, 42, 185, 16, 12, 12, 42, 42, 42, 12 
 DB 114, 184, 184, 184, 16, 16, 16, 184, 184, 114, 12, 42, 42, 42, 42, 12, 16, 16, 12, 42, 42, 42, 42, 42, 42, 65, 65, 114, 16, 16, 16, 16, 16, 138, 42, 42, 42, 42, 12, 6 
 DB 42, 42, 42, 42, 42, 42, 42, 65, 24, 208, 16, 16, 16, 16, 16, 140, 42, 42, 42, 42, 42, 115, 16, 16, 16, 16, 16, 16, 16, 137, 65, 65, 42, 65, 65, 65, 65, 65, 42, 42 
 DB 42, 42, 42, 42, 65, 186, 16, 138, 43, 42, 42, 42, 42, 42, 65, 65, 164, 185, 16, 208, 25, 65, 42, 42, 42, 42, 42, 42, 42, 185, 16, 138, 42, 42, 42, 42, 42, 6, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 186, 42, 42, 42, 43, 43, 140, 185, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 183, 139, 65, 42, 42, 65, 64, 65, 65 
 DB 65, 42, 42, 42, 42, 42, 42, 42, 16, 16, 6, 43, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 16, 16, 6, 42, 42, 42, 42, 42 
 DB 114, 16, 16, 16, 16, 16, 16, 16, 16, 138, 42, 42, 42, 42, 43, 6, 16, 16, 12, 65, 65, 65, 65, 42, 65, 12, 65, 211, 16, 16, 16, 16, 16, 138, 42, 42, 42, 42, 42, 6 
 DB 43, 43, 43, 42, 43, 43, 115, 114, 209, 16, 16, 16, 16, 16, 184, 140, 43, 43, 43, 43, 43, 115, 16, 16, 16, 16, 16, 16, 16, 186, 114, 114, 114, 114, 114, 114, 114, 114, 6, 43 
 DB 43, 43, 43, 42, 65, 187, 16, 139, 43, 43, 42, 43, 43, 42, 114, 187, 187, 16, 16, 184, 187, 114, 114, 43, 43, 43, 43, 43, 65, 185, 16, 139, 43, 42, 43, 43, 43, 6, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 186, 43, 43, 43, 43, 43, 65, 186, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 185, 114, 114, 114, 113, 113, 114, 114 
 DB 114, 6, 43, 43, 43, 43, 43, 42, 16, 16, 6, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 42, 16, 16, 42, 43, 43, 43, 43, 43 
 DB 115, 16, 16, 16, 16, 16, 16, 16, 16, 137, 43, 43, 43, 43, 43, 42, 16, 16, 113, 114, 114, 114, 114, 114, 114, 114, 114, 185, 16, 16, 16, 16, 16, 138, 43, 43, 43, 42, 43, 42 
 DB 43, 43, 43, 43, 43, 43, 186, 16, 16, 16, 16, 16, 16, 16, 16, 140, 43, 43, 43, 43, 43, 116, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 187, 66 
 DB 43, 43, 43, 43, 43, 187, 16, 163, 43, 43, 43, 43, 43, 6, 16, 16, 16, 16, 16, 167, 16, 16, 185, 66, 43, 43, 43, 43, 43, 186, 16, 140, 43, 43, 43, 43, 14, 140, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 187, 66, 43, 43, 43, 43, 66, 186, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 16, 138, 43, 43, 43, 43, 43, 43, 16, 16, 6, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 16, 16, 140, 43, 43, 43, 43, 43 
 DB 138, 16, 16, 16, 16, 16, 16, 16, 16, 138, 43, 43, 43, 43, 43, 140, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 167, 166, 16, 16, 16, 140, 44, 43, 43, 43, 43, 6 
 DB 43, 43, 43, 43, 43, 43, 209, 16, 16, 16, 16, 16, 16, 16, 16, 25, 43, 43, 43, 43, 14, 116, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 187, 66 
 DB 43, 43, 43, 43, 43, 187, 16, 163, 43, 43, 43, 43, 43, 6, 16, 16, 16, 16, 16, 16, 16, 16, 185, 66, 43, 43, 43, 43, 66, 186, 16, 164, 43, 43, 43, 43, 43, 140, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 187, 66, 43, 43, 43, 43, 66, 186, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 16, 138, 43, 43, 43, 43, 43, 43, 16, 16, 6, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 16, 16, 43, 14, 43, 43, 43, 43 
 DB 115, 16, 16, 16, 16, 16, 16, 16, 16, 138, 43, 43, 43, 43, 14, 65, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 167, 16, 16, 16, 16, 140, 43, 43, 43, 43, 43, 43 
 DB 43, 43, 43, 43, 43, 43, 208, 16, 16, 16, 16, 16, 16, 16, 16, 140, 44, 43, 43, 43, 44, 116, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 187, 14 
 DB 43, 43, 43, 43, 14, 188, 16, 164, 44, 43, 43, 43, 44, 43, 16, 16, 16, 16, 16, 16, 16, 16, 186, 43, 43, 43, 43, 43, 14, 186, 16, 140, 44, 43, 43, 44, 43, 6, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 187, 14, 43, 43, 43, 43, 43, 187, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 16, 115, 44, 43, 43, 43, 43, 43, 16, 16, 6, 43, 43, 43, 43, 43, 43, 43, 14, 43, 138, 138, 6, 14, 43, 43, 43, 43, 43, 43, 43, 43, 18, 16, 138, 139, 115, 43, 44, 43 
 DB 43, 116, 116, 188, 16, 16, 187, 116, 116, 43, 44, 43, 43, 139, 139, 137, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 116, 116, 116, 43, 43, 43, 43, 140, 138, 137 
 DB 43, 43, 43, 43, 44, 44, 186, 16, 16, 16, 16, 16, 16, 16, 16, 26, 44, 43, 44, 43, 14, 116, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 187, 67 
 DB 44, 44, 43, 44, 14, 188, 16, 164, 44, 43, 43, 43, 44, 43, 16, 16, 16, 16, 16, 16, 16, 16, 186, 14, 44, 44, 44, 43, 14, 186, 16, 164, 44, 44, 43, 43, 14, 6, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 187, 14, 43, 43, 43, 44, 14, 187, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 16, 139, 44, 44, 44, 44, 44, 43, 16, 16, 43, 44, 43, 43, 43, 43, 43, 44, 14, 6, 16, 16, 115, 14, 44, 43, 44, 44, 44, 43, 44, 43, 16, 16, 16, 16, 16, 43, 44, 44 
 DB 14, 14, 68, 140, 16, 16, 139, 68, 14, 14, 43, 44, 43, 185, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 26, 14, 14, 14, 43, 44, 6, 16, 16, 16 
 DB 14, 14, 14, 44, 44, 45, 187, 16, 16, 16, 16, 16, 16, 16, 16, 6, 44, 44, 44, 44, 14, 116, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 187, 14 
 DB 44, 44, 44, 44, 14, 188, 16, 164, 44, 43, 44, 43, 44, 6, 16, 16, 16, 16, 16, 16, 16, 16, 186, 14, 44, 44, 44, 44, 14, 186, 16, 164, 67, 14, 44, 44, 44, 6, 16, 16 
 DB 16, 16, 16, 16, 16, 16, 188, 14, 44, 44, 14, 67, 67, 187, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 16, 115, 44, 44, 44, 44, 44, 43, 16, 16, 43, 44, 44, 44, 43, 43, 14, 14, 67, 25, 16, 16, 139, 67, 67, 14, 44, 44, 44, 44, 44, 43, 16, 16, 16, 16, 16, 26, 67, 14 
 DB 43, 44, 14, 116, 16, 16, 115, 14, 44, 44, 14, 67, 66, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 43, 44, 43, 44, 14, 67, 26, 16, 16, 16 
 DB 6, 6, 43, 44, 44, 44, 140, 140, 164, 164, 164, 164, 164, 140, 140, 14, 44, 44, 44, 44, 14, 116, 16, 21, 23, 164, 164, 164, 164, 164, 164, 164, 140, 140, 164, 164, 140, 140, 140, 14 
 DB 44, 44, 44, 44, 14, 188, 16, 164, 44, 44, 44, 44, 14, 45, 16, 16, 16, 16, 16, 16, 16, 16, 186, 67, 44, 44, 44, 44, 14, 187, 16, 138, 43, 6, 43, 44, 44, 43, 140, 163 
 DB 164, 164, 163, 164, 164, 140, 116, 14, 44, 44, 6, 115, 115, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 139, 164, 140, 164, 164, 164, 164, 164, 164, 164, 140, 140, 140, 140 
 DB 140, 25, 14, 44, 44, 44, 44, 43, 16, 16, 43, 44, 44, 44, 44, 14, 43, 116, 116, 115, 16, 16, 187, 116, 116, 6, 44, 44, 44, 44, 44, 14, 18, 16, 16, 16, 16, 139, 116, 116 
 DB 43, 14, 14, 43, 163, 163, 43, 14, 44, 45, 116, 115, 115, 16, 16, 16, 16, 16, 166, 164, 165, 164, 164, 164, 140, 140, 140, 140, 140, 140, 43, 44, 14, 43, 116, 116, 139, 16, 16, 16 
 DB 16, 16, 187, 67, 44, 44, 44, 44, 14, 44, 14, 14, 14, 14, 14, 14, 44, 44, 44, 44, 14, 116, 16, 26, 14, 14, 14, 14, 14, 14, 44, 44, 44, 44, 14, 14, 44, 44, 44, 44 
 DB 44, 44, 44, 44, 14, 188, 16, 164, 44, 44, 44, 44, 44, 45, 16, 16, 16, 16, 16, 16, 16, 16, 186, 14, 44, 44, 44, 44, 14, 187, 16, 16, 16, 16, 116, 14, 44, 44, 14, 44 
 DB 14, 14, 14, 14, 44, 44, 44, 44, 44, 14, 188, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 14, 14, 44, 44, 44, 44, 14, 44, 44, 44, 44, 44, 14, 14 
 DB 14, 44, 44, 44, 44, 44, 14, 14, 16, 16, 66, 14, 44, 44, 44, 44, 140, 16, 16, 16, 16, 16, 16, 16, 16, 236, 14, 44, 44, 44, 44, 45, 18, 16, 16, 16, 166, 166, 16, 16 
 DB 6, 14, 44, 44, 14, 14, 44, 44, 14, 43, 16, 16, 16, 16, 16, 16, 16, 186, 14, 14, 44, 14, 44, 14, 14, 14, 14, 44, 44, 44, 44, 44, 14, 140, 16, 16, 16, 16, 16, 16 
 DB 16, 16, 187, 68, 14, 44, 44, 44, 44, 14, 44, 44, 14, 14, 14, 14, 44, 44, 44, 44, 14, 116, 16, 27, 44, 14, 14, 14, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44 
 DB 44, 44, 44, 44, 14, 188, 16, 24, 44, 44, 44, 44, 44, 45, 16, 16, 16, 16, 16, 16, 16, 16, 189, 14, 44, 44, 44, 44, 14, 187, 16, 16, 16, 16, 140, 14, 44, 44, 14, 14 
 DB 14, 44, 14, 14, 44, 44, 44, 44, 44, 14, 188, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 18, 14, 14, 44, 44, 44, 14, 44, 44, 44, 44, 44, 44, 14, 14 
 DB 14, 44, 44, 44, 44, 44, 14, 14, 16, 16, 66, 14, 44, 44, 44, 14, 140, 16, 16, 16, 16, 16, 16, 16, 16, 138, 14, 44, 44, 44, 44, 44, 18, 16, 16, 16, 166, 166, 16, 16 
 DB 6, 14, 14, 14, 14, 14, 44, 44, 14, 43, 16, 16, 16, 16, 16, 16, 16, 186, 14, 14, 44, 14, 44, 14, 14, 14, 14, 44, 44, 44, 44, 44, 14, 140, 16, 16, 16, 16, 16, 16 
 DB 16, 16, 18, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 164, 24, 24, 24, 20, 16, 22, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 
 DB 24, 24, 164, 164, 24, 189, 16, 21, 24, 164, 24, 24, 24, 165, 16, 16, 16, 16, 16, 16, 16, 16, 16, 23, 24, 24, 24, 24, 24, 18, 16, 16, 16, 16, 20, 24, 164, 140, 164, 164 
 DB 24, 24, 24, 24, 24, 24, 24, 24, 24, 164, 209, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 140, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 
 DB 24, 24, 164, 24, 24, 24, 24, 24, 16, 16, 165, 24, 24, 24, 164, 164, 20, 16, 16, 16, 16, 16, 16, 16, 16, 19, 164, 164, 24, 24, 25, 140, 16, 16, 16, 16, 16, 16, 16, 16 
 DB 141, 164, 24, 24, 24, 24, 24, 24, 24, 140, 16, 16, 16, 16, 16, 16, 16, 16, 23, 24, 24, 24, 164, 164, 24, 24, 24, 24, 24, 24, 24, 24, 25, 142, 16, 16, 16, 16, 16, 16 
x_position dw 50
y_position dw 30

first_player_wins db 'First Player Wins' 

second_player_wins db 'Second player wins'

GAME_OVER_mess db 'Press ESC Key to Return to main menu $'

Goodbye_mess db 'Goodbye *^-^* $'

;;;;;;;CHAT ;;; 
	First_cursor_X         DB  6
	First_cursor_Y         DB  1

	; SECOND CURSOR USED FOR RECEIVING
	SECOND_CURSOR_X        DB  6
	SECOND_CURSOR_Y        DB  13

	start_position_x       equ 6

	LETTER_SENT            DB  ?
	LETTER_RECEIVING       DB  ?


	Line_status_register   equ 3FDH
	TRANSMIT_DATA_REGISTER equ 3F8H
	Line_Control_Register  equ 3fbh

	end_line               db  76

	IS_ENTER               DB  0
	IS_BACKSPACE           DB  0
	;players Name
	first_chatter          db  'chatter 1 : $'
	second_chatter         db  'chatter 2 : $'
	chat_end_string        db  'To end chat press ESC $'



			
;;; IN GAME CHAT MODULE 
	in_game_cursor_up db 0
	in_game_cursor_down db 0
	in_game_received_val db 0
	in_game_to_send_val  db 0
	in_game_iterator db 0
	in_game_end_chat db 0 
	is_quit db 0



level DB 0
;------------------------------------------------------------
;;FOR MAKING GAME BEING PLAYED BY TWO PCS
LETTER_RECEIVED      DB  ?;LETTER RECIEVED BY UART
is_master DB 01h ;WHEN A PLAYER SENT INVI. TO THE ANOTHER ONE SO HE IS THE MASTER (MASTER VALUE=1)
STORED_KEY_OR_UART DB ?;LETTER RECIEVED BY UART OR KEY OF KEYBOARD(OPTIONS OF CONTROLLING THE PLAYERS)
;---------------------------------------------------------------------------
.code
MAIN PROC FAR
	                                mov  ax,@data
	                                mov  ds ,ax
                                    MOV ES, AX
								    CALL Far PTR Take_User_Data
									Call FAR PTR MAIN_MENU
									Call FAR PTR CLEAR_SCREEN
									mov ah,2
									mov dx,090fh
									int 10h
									PRINT_Messages Goodbye_mess
									mov ah,0
									int 16h
									RET
MAIN ENDP
	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
;taking the character from the user and reacting to it
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
;taking the character from the user and reacting to it
;taking the character from the user and reacting to it
MOVE_PLAYERS PROC FAR

;Check if any player is freezed--> then reduce its freezing time
	cmp first_player_freeze,0
	je Is_Second_Player_Freeze
	dec first_player_freeze

	Is_Second_Player_Freeze:
	cmp second_player_freeze,0
	je Check_Pressed
	dec second_player_freeze



	Check_Pressed:
                                   ;TO KNOW THAT I AM THE MASTER OR THE SLAVE
	                                mov DL,GAME_MASTER
	                                CMP DL, 0
	                                jz  I_AM_NOT_MASTER
                                	


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MASTER;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	                          ;check if any key is being pressed
	                                 MOV  AH,01h
	                                 INT  16h
	                                 JnZ  CHECK_MOVEMENT_MASTER_KEYBOARD	     	;ZF = 1, JZ -> Jump If Zero
									 jmp CHECK_MOVEMENT_MASTER_UART

							      
	CHECK_MOVEMENT_MASTER_KEYBOARD:     
	;Read which key is being pressed (AL = ASCII character/ AH = SCAN CODE)
	                                 MOV  AH,00h
	                                 INT  16h
						            SendChar AH 
									 cmp AH,39h   ;this is space key(ATTACK BUTTON)
									 jne First_moved_1
									 cmp first_player_freeze,0
									 jg End_Moving					;if it is still freezed
									 cmp First_Is_Collided,1                ;If he is colliding, he cannot attack
                                     JE End_Moving
									 call FAR PTR First_Player_Attack
									 jmp End_Moving

									First_moved_1:
									cmp first_player_freeze,0
									jg End_Moving					;if it is still freezed
									MOV STORED_KEY_OR_UART,AH
									call FAR PTR CHECK_FIRST_PLAYER_MOVEMENT
									jmp End_Moving

CHECK_MOVEMENT_MASTER_UART:
                            ;;;;;;;;;;;;;;;;;;;;;;;RECIEVEFROM_UART;;;;;;;;;;;;;;;;;;;;;;;;;;; 
	                                ReceiveCharNotAmustToRecieve
							        MOV LETTER_RECEIVED,AL
                                ;;;;;;;;;;;;;;;;;;;;;;;RECIEVEFROM_UART;;;;;;;;;;;;;;;;;;;;;;;;;;; 
									 cmp LETTER_RECEIVED,1Ch  ;this is Enter (ATTACK BUTTON)
									 jne Second_MOVED_1
									 cmp second_player_freeze,0
									 jg End_Moving					;if it is still freezed
									 cmp Second_Is_Collided,1                ;If he is colliding, he cannot attack
                                     JE End_Moving
									 call FAR PTR Second_Player_Attack
									 jmp End_Moving

				
									Second_MOVED_1:
									 cmp second_player_freeze,0
									 jg End_Moving					;if it is still freezed
									 MOV STORED_KEY_OR_UART,AL
								    call FAR PTR CHECK_SECOND_PLAYER_MOVEMENT
									 jmp End_Moving


;/////////////////////////////////////////////////////////////////////////////////////////////////////SLAVE/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   I_AM_NOT_MASTER:
  
									 MOV  AH,01h
	                                 INT  16h
	                                 JnZ  CHECK_MOVEMENT_SLAVE_KEYBOARD	     	;ZF = 1, JZ -> Jump If Zero
									 JZ CHECK_MOVEMENT_SLAVE_UART


		CHECK_MOVEMENT_SLAVE_KEYBOARD:							 
	;Read which key is being pressed (AL = ASCII character/ AH = SCAN CODE)
	                                 MOV  AH,00h
	                                 INT  16h
						            SendChar AH 
									 cmp AH,1Ch   ;this is ENTER key (ATTACK BUTTON)
									 jne SECOND_moved_2
									 cmp SECOND_player_freeze,0
									 jg End_Moving					;if it is still freezed
									 cmp SECOND_Is_Collided,1                ;If he is colliding, he cannot attack
                                     JE End_Moving
									 call FAR PTR SECOND_Player_Attack
									 jmp End_Moving

									SECOND_moved_2:
									cmp first_player_freeze,0
									jg End_Moving					;if it is still freezed
									MOV STORED_KEY_OR_UART,AH
									call FAR PTR CHECK_SECOND_PLAYER_MOVEMENT
									jmp End_Moving

CHECK_MOVEMENT_SLAVE_UART:
                                    ;;;;;;;;;;;;;;;;;;;;;;;RECIEVEFROM_UART;;;;;;;;;;;;;;;;;;;;;;;;;;; 
                                    ReceiveCharNotAmustToRecieve
							        MOV LETTER_RECEIVED,AL
									;;;;;;;;;;;;;;;;;;;;;;;RECIEVEFROM_UART;;;;;;;;;;;;;;;;;;;;;;;;;;; 
	                                 cmp LETTER_RECEIVED,39h  ;this is SPACE (ATTACK BUTTON)
									 jne FIRST_MOVED_2
									 cmp FIRST_player_freeze,0
									 jg End_Moving					;if it is still freezed
									 cmp FIRST_Is_Collided,1                ;If he is colliding, he cannot attack
                                     JE End_Moving
									 call FAR PTR FIRST_Player_Attack
									 jmp End_Moving

				
									FIRST_MOVED_2:
									 cmp second_player_freeze,0
									 jg End_Moving					;if it is still freezed
									 MOV STORED_KEY_OR_UART,AL
									call FAR PTR CHECK_FIRST_PLAYER_MOVEMENT
									;call FAR PTR CHECK_SECOND_PLAYER_MOVEMENT
									 jmp End_Moving

			End_Moving:
			RET
				
MOVE_PLAYERS ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
;this will check for direction of the attack

First_Player_Attack PROC 
	mov ax,first_player_X
	cmp ax,second_player_X
	jGE Second_IS_IN_THE_LEFT_SIDE

	call FAR PTR First_Attack_Left_TO_Right
	RET
	Second_IS_IN_THE_LEFT_SIDE:
	Call far PTR First_Attack_Right_TO_Left

	RET
First_Player_Attack ENDP


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
;this will check for direction of the attack

Second_Player_Attack PROC 
	mov ax,Second_player_X
	cmp ax,First_player_X
	jGE First_IS_IN_THE_LEFT_SIDE

	call FAR PTR Second_Attack_Left_TO_Right
	RET
	First_IS_IN_THE_LEFT_SIDE:
	Call far PTR Second_Attack_Right_TO_Left

	RET
Second_Player_Attack ENDP


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	

;clear the console
CLEAR_SCREEN PROC FAR
	                                 MOV  AH,00h                          	;set the configuration to video mode
	                                 MOV  AL,13h                          	;choose the video mode
	                                 INT  10h                             	;execute the configuration
		
	                                 MOV  AH,0fh                          	;set the configuration
	                                 MOV  BH,00h                          	;to the background color
	                                 MOV  BL,00h                          	;choose black as background color
	                                 INT  10h                             	;execute the configuration
			
	                                 RET
CLEAR_SCREEN ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	

;draw the image of player one
draw_p1 proc FAR
	;;;;;;;;;;;;;;
	                                 mov  ah,0ch                          	;this means with int 10h ---> you're drawing a pixel
	                                 mov  di,0
	                                 mov  al,p1[DI]                       	;the pixel color
	                                 mov  bh,0                            	;the page number
	                                 mov  cx,first_player_X               	;the starting x-position (column)
	                                 add  cx,PLAYERS_WIDTH                	;as we draw in the reversed order
	                                 mov  dx,first_player_Y               	;the starting y-position (row)
	                                 add  dx,PLAYERS_HEIGHT               	;as we draw in the reversed order
	;here we loop for the image size (player_size)
	fill_p1:                         
	                                 cmp  al,0
	                                 jz   pass_the_pixel
	                                 int  10h
	pass_the_pixel:                  
	                                 inc  di
	                                 mov  al,p1[DI]
	                                 dec  cx
	                                 cmp  cx,first_player_X
	                                 jnz  fill_p1                         	;if not zero so we continue to the same row
	                                 mov  cx,first_player_X               	;the starting x-position (column)
	                                 add  cx,PLAYERS_WIDTH                	;as we draw in the reversed order
	                                 dec  dx                              	;if not zero so we continue to draw the background
	                                 cmp  dx,first_player_Y
	                                 jnz  fill_p1
	;;;;;;;;;;;;;;
	                                 ret
draw_p1 endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	

;draw the image of player two
draw_p2 proc FAR
	;;;;;;;;;;;;;;
	                                 mov  ah,0ch                          	;this means with int 10h ---> you're drawing a pixel
	                                 mov  di,0
	                                 mov  al,p2[DI]                       	;the pixel color
	                                 mov  bh,0                            	;the page number
	                                 mov  cx,second_player_X              	;the starting x-position (column)
	                                 add  cx,PLAYERS_WIDTH                	;as we draw in the reversed order
	                                 mov  dx,SECOND_PLAYER_Y              	;the starting y-position (row)
	                                 add  dx,PLAYERS_HEIGHT               	;as we draw in the reversed order
	;here we loop for the image size (player_size)
	fill_p2:                         
	                                 cmp  al,0
	                                 jz   pass_the_pixel_2
	                                 int  10h
	pass_the_pixel_2:                
	                                 inc  di
	                                 mov  al,p2[DI]
	                                 dec  cx
	                                 cmp  cx,second_player_X
	                                 jnz  fill_p2                         	;if not zero so we continue to the same row
	                                 mov  cx,second_player_X              	;the starting x-position (column)
	                                 add  cx,PLAYERS_WIDTH                	;as we draw in the reversed order
	                                 dec  dx                              	;if not zero so we continue to draw the background
	                                 cmp  dx,SECOND_PLAYER_Y
	                                 jnz  fill_p2
	;;;;;;;;;;;;;;
	                                 ret
draw_p2 endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	

;fill the whole screen with the background color
draw_background proc FAR

	;;;;;;;;;;;;;;
	                                 mov  ah,0ch                          	;this means with int 10h ---> you're drawing a pixel
	                                 mov  al,background_color             	;the pixel color
	                                 mov  bh,0                            	;the page number
	                                 mov  cx,0                            	;the x-position (column)
	                                 mov  dx,0                            	;the y-position (row)
	;here we loop for 4/5 of the screen
	fillblue:                        
	                                 int  10h
	                                 inc  cx
	                                 cmp  cx,WINDOW_WIDTH
	                                 jnz  fillblue                        	;if not zero so we continue to the same row
	                                 inc  dx
	                                 mov  cx,0
	                                 cmp  dx,WINDOW_HEIGHT                	;if not zero so we continue to draw the background
	                                 jnz  fillblue
	;;;;;;;;;;;;;;
	                                 ret
draw_background endp


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	

;draw a number of hearts that is first_player_health
draw_h1 PROC FAR

	;check if health is zero, don't draw
	mov ax,first_player_health
	cmp ax,0
	jnz first_player_alive

	RET
	first_player_alive:
    mov  ah,0ch                          	;this means with int 10h ---> you're drawing a pixel
	mov PRE_POSITION_X,first_player_health_X
	mov PRE_POSITION_Y,first_player_health_Y
	mov si,0
	CLEAR_H1:
											mov al,background_color
											mov bh,0
											mov cx,PRE_POSITION_X              	;the starting x-position (column)
											add cx,health_bar_width             
											mov dx,pre_position_y
											add dx,window_bounds_upper
											
											fill_h1_background:
											int  10h
											dec cx
											cmp cx,pre_position_x 
											jnz fill_h1_background
											mov cx,PRE_POSITION_X              	;the starting x-position (column)
											add cx,health_bar_width             
											dec dx
											cmp dx,PRE_POSITION_Y
											jnz fill_h1_background
	draw_one_Red_heart:
			;;;;;;;;;;;;;;
											mov  di,0
											mov  al,h1[DI]                       	;the pixel color
											mov  bh,0                            	;the page number
											mov  cx,PRE_POSITION_X          ;the starting x-position (column)
											add  cx,heart_WIDTH                	;as we draw in the reversed order
											mov  dx,PRE_POSITION_Y          ;the starting y-position (row)
											add  dx,heart_HEIGHT               	;as we draw in the reversed order
			;here we loop for the image size (player_size)
			fill_h1:                         
											cmp  al,0
											jz   pass_the_pixel__1
											int  10h
			pass_the_pixel__1:                
											inc  di
											mov  al,h1[DI]
											dec  cx
											cmp  cx,PRE_POSITION_X
											jnz  fill_h1                         	;if not zero so we continue to the same row
											mov  cx,PRE_POSITION_X              	;the starting x-position (column)
											add  cx,heart_WIDTH                	;as we draw in the reversed order
											dec  dx                              	;if not zero so we continue to draw the background
											cmp  dx,PRE_POSITION_Y
											jnz  fill_h1
			;;;;;;;;;;;;;;
	inc si 
	cmp si,first_player_health
	jz finish_drawing_h1
	mov di,pre_position_x
	add di,heart_WIDTH
	mov pre_position_x,di

	jmp draw_one_Red_heart
	finish_drawing_h1:	
	ret

draw_h1 ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	

;draw a number of hearts that is second_player_health
draw_h2 PROC FAR
	;check if health is zero, don't draw
	mov ax,second_player_health
	cmp AX,0
	jnz second_player_alive
	RET

	second_player_alive:
    mov  ah,0ch                          	;this means with int 10h ---> you're drawing a pixel
	mov PRE_POSITION_X,second_player_health_X
	mov PRE_POSITION_Y,second_player_health_Y
	mov si,0
	CLEAR_H2:
											mov al,background_color
											mov bh,0
											mov cx,WINDOW_WIDTH              	;the ending x-position (column)
											SUB cx,health_bar_width             
											mov dx,pre_position_y
											add dx,window_bounds_upper
											
											fill_h2_background:
											int  10h
											INC cx
											cmp cx,WINDOW_WIDTH 
											jnz fill_h2_background
											mov cx,WINDOW_WIDTH              	;the starting x-position (column)
											sub cx,health_bar_width             
											dec dx
											cmp dx,PRE_POSITION_Y
											jnz fill_h2_background

	draw_one_Blue_heart:
			;;;;;;;;;;;;;;
											mov  di,0
											mov  al,h2[DI]                       	;the pixel color
											mov  bh,0                            	;the page number
											mov  cx,PRE_POSITION_X          ;the starting x-position (column)
											add  cx,heart_WIDTH                	;as we draw in the reversed order
											mov  dx,PRE_POSITION_Y          ;the starting y-position (row)
											add  dx,heart_HEIGHT               	;as we draw in the reversed order
			;here we loop for the image size (player_size)
			fill_h2:                         
											cmp  al,0
											jz   pass_the_pixel__2
											int  10h
			pass_the_pixel__2:                
											inc  di
											mov  al,h2[DI]
											dec  cx
											cmp  cx,PRE_POSITION_X
											jnz  fill_h2                         	;if not zero so we continue to the same row
											mov  cx,PRE_POSITION_X              	;the starting x-position (column)
											add  cx,heart_WIDTH                	;as we draw in the reversed order
											dec  dx                              	;if not zero so we continue to draw the background
											cmp  dx,PRE_POSITION_Y
											jnz  fill_h2
			;;;;;;;;;;;;;;
	inc si 
	cmp si,second_player_health
	jz finish_drawing_h2
	mov di,pre_position_x
	sub di,heart_WIDTH
	mov pre_position_x,di

	jmp draw_one_Blue_heart
	finish_drawing_h2:	
	ret

draw_h2 ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FILLRECTANGLE proc FAR

                            MOV DI,0
	                        PUSH                LEN
	FILL:                   
	                        PUSH                LEN
	FILLINNER:              


	                        MOV                 AH,0CH
	                        MOV                 AL,Barrier_array[DI]
							INC                 DI
	                        MOV                 BH,0H
    
	                        MOV                 CX,LEN
	                        MOV                 DX,WID
	                        INT                 10H

	                        MOV                 BX,LENMAX
	                        INC                 LEN
	                        CMP                 BX,LEN
	                        JNZ                 FILLINNER
	                        POP                 LEN

	                        INC                 WID
	                        MOV                 BX,WIDMAX
	                        CMP                 BX,WID
	                        JNZ                 FILL

	                        POP                 WID
	                        RET
FILLRECTANGLE ENDP



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


DRAW_BARRIER1 PROC FAR
;As we use pre_position variables as temp, and we always call draw_barrier after we update their values 
;We need to condition only one special case is when we draw them for the first time
mov ax,pre_position_y
cmp ax,0
jz first_time_to_draw1

							

							first_time_to_draw1:

	                        mov                 Ax,X_BARRIER1
	                        mov                 LEN,Ax
	                        add                 Ax, BARRIER_HORIZONTAL_SIZE
	                        mov                 LENMAX,ax
	                        mov                 ax,Y_BARRIER1
	                        mov                 WID,ax
	                        add                 ax, BARRIER_VERTICAL_SIZE
	                        mov                 WIDMAX,ax
	              

	                        CALL  FAR PTR              CHECK_BOUNDARY_BARRIER1
	                        RET
DRAW_BARRIER1 endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DRAW_BARRIER2 PROC FAR

;As we use pre_position variables as temp, and we always call draw_barrier after we update their values 
;We need to condition only one special case is when we draw them for the first time
mov ax,pre_position_y
cmp ax,0
jz first_draw2

					
							first_draw2:

                           ;; CALL                CHECK_OVERLAPPING_BARRIER2
	                        mov                 Ax,X_BARRIER2
	                        mov                 LEN,Ax
	                        add                 Ax, BARRIER_HORIZONTAL_SIZE
	                        mov                 LENMAX,ax
	                        mov                 ax,Y_BARRIER2
	                        mov                 WID,ax
	                        add                 ax, BARRIER_VERTICAL_SIZE
	                        mov                 WIDMAX,ax
	             
	                        CALL  FAR PTR              CHECK_BOUNDARY_BARRIER2

	                        RET
DRAW_BARRIER2 ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;checking that this move is allowed 
CHECK_FIRST_PLAYER_MOVEMENT PROC FAR
;STORE THE PREVIOUS POSITION OF PLAYER 1, we will use it if the new position causes collision (the same as push it in the stack)
	                                 MOV  BX,first_player_X
	                                 MOV  PRE_POSITION_X,BX
	                                 mov  BX,first_player_Y
	                                 MOV  PRE_POSITION_Y,BX
	;if it is 'w' or 'W' move up
	                                 CMP  STORED_KEY_OR_UART,11H                    	
	                                 JE   MOVE_FIRST_PLAYER_UP
	                            
		
	;if it is 's' or 'S' move down
	                                 CMP  STORED_KEY_OR_UART,1FH                    	
	                                 JE   MOVE_FIRST_PLAYER_DOWN
		
	;if it is 'D' or 'd' move first player right
	                                 cmp  STORED_KEY_OR_UART,20H
	                                 je   MOVE_FIRST_PLAYER_right
	                               

	; if it is 'A' or 'a' move first player left
	                                 cmp  STORED_KEY_OR_UART,1EH
	                                 je   MOVE_FIRST_PLAYER_LEFT
	                                
									 JMP Exit_FIRST_PLAYER_MOVEMENT           	
	MOVE_FIRST_PLAYER_UP:            
	                                 MOV  AX,PLAYERS_VELOCITY
	                                 SUB  first_player_Y,AX
			
	                                 MOV  AX,window_bounds_upper
	                                 CMP  first_player_Y,AX
	                                 JL   FIX_FIRST_PLAYER_TOP_POSITION     ;it will jump if first_player_Y < AX ---> outside the window
	                                 JMP  CHECK_FOR_COLLISION_1
	FIX_FIRST_PLAYER_TOP_POSITION:                                        	;Return it to inside the window 
	                                 MOV  first_player_Y,AX
	                                 JMP  CHECK_FOR_COLLISION_1
			
	MOVE_FIRST_PLAYER_DOWN:          
	                                 MOV  AX,PLAYERS_VELOCITY
	                                 ADD  first_player_Y,AX
	                                 MOV  AX,WINDOW_HEIGHT
	                                 SUB  AX,WINDOW_BOUNDS
	                                 SUB  AX,PLAYERS_HEIGHT
	                                 CMP  first_player_Y,AX
	                                 JG   FIX_FIRST_PLAYER_BOTTOM_POSITION ;it will jump if first_player_Y > AX---> outside the window
	                                 JMP  CHECK_FOR_COLLISION_1
	FIX_FIRST_PLAYER_BOTTOM_POSITION:                                     	;Return it to inside the window
	                                 MOV  first_player_Y,AX
	                                 JMP  CHECK_FOR_COLLISION_1
		
	MOVE_FIRST_PLAYER_right:         
	                                 MOV  AX,PLAYERS_VELOCITY
	                                 ADD  first_player_X,AX
	                                 MOV  AX,WINDOW_WIDTH
	                                 SUB  AX,PLAYERS_WIDTH
	                                 SUB  AX,WINDOW_BOUNDS
	                                 cmp  first_player_X,AX
	                                 JG   FIX_FIRST_PLAYER_RIGHT_POSITION  ;it will jump if first_player_X > AX---> outside the window
	                                 JMP  CHECK_FOR_COLLISION_1
	FIX_FIRST_PLAYER_RIGHT_POSITION:                                      	;Return it to inside the window
	                                 MOV  first_player_X,AX
	                                 JMP  CHECK_FOR_COLLISION_1

	MOVE_FIRST_PLAYER_LEFT:          
	                                 mov  ax,PLAYERS_VELOCITY
	                                 SUB  first_player_X,ax
	                                 MOV  AX,WINDOW_BOUNDS
	                                 CMP  first_player_X,AX
	                                 JL   FIX_FIRST_PLAYER_LEFT_POSITION
	                                 JMP  CHECK_FOR_COLLISION_1
	FIX_FIRST_PLAYER_LEFT_POSITION:  
	                                 MOV  first_player_X,AX
	                                 JMP  CHECK_FOR_COLLISION_1
       
	CHECK_FOR_COLLISION_1:           
	; maxx1 > minx2 && minx1 < maxx2 && maxy1 > miny2 && miny1 < maxy2
	                                 MOV  AX,first_player_X               	;IF maxx1 > minx2
	                                 ADD  AX,PLAYERS_WIDTH
	                                 CMP  AX,second_player_X
	                                 JNG  Exit_FIRST_PLAYER_MOVEMENT           	;No collision will happen
		
	                                 MOV  AX,second_player_X              	;IF minx1 < maxx2
	                                 ADD  AX,PLAYERS_WIDTH
	                                 CMP  first_player_X,AX
	                                 JNL  Exit_FIRST_PLAYER_MOVEMENT           	;No collision will happen


	                                 MOV  AX,SECOND_PLAYER_Y              	;IF maxy1 > miny2
	                                 ADD  AX,PLAYERS_HEIGHT
	                                 CMP  AX,first_player_Y
	                                 JNG  Exit_FIRST_PLAYER_MOVEMENT           	;No collision will happen
		
	                                 MOV  AX,first_player_Y               	;IF  miny1 < maxy2
	                                 ADD  AX,PLAYERS_HEIGHT
	                                 CMP  SECOND_PLAYER_Y,AX
	                                 JNL  Exit_FIRST_PLAYER_MOVEMENT           	;No collision will happen

	                                 MOV  DX,PRE_POSITION_X                	; If it reached here then there will be a collision
	                                 MOV  first_player_X,DX               	; Return the old values
	                                 MOV  DX,PRE_POSITION_Y
	                                 MOV  first_player_Y,DX
									 RET
	Exit_FIRST_PLAYER_MOVEMENT:
									call FAR PTR Update_Players
									call FAR PTR draw_p1
	
	RET
CHECK_FIRST_PLAYER_MOVEMENT ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;checking that this move is allowed 


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;checking that this move is allowed 
CHECK_SECOND_PLAYER_MOVEMENT PROC  FAR
	                                 mov  DX,second_player_X
	                                 MOV  PRE_POSITION_X,DX
	                                 mov  DX,SECOND_PLAYER_Y
	                                 MOV  PRE_POSITION_Y,DX

	;if it is 'o' or 'O' move up
	                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IN   AX, 60H
								
	                                 CMP  STORED_KEY_OR_UART, 48H  ;(UP_ARROW)
	                                 JE   MOVE_SECOND_PLAYER_UP
	                                 CMP  STORED_KEY_OR_UART, 50H ;(DOWN_ARROW)
	                                 JE   MOVE_SECOND_PLAYER_DOWN
	                                 CMP  STORED_KEY_OR_UART, 4BH ;(LEST_ARROW)
	                                 JE   MOVE_SECOND_PLAYER_left
	                                 CMP  STORED_KEY_OR_UART, 4DH;(RIGHT_ARROW)
	                                 JE   MOVE_SECOND_PLAYER_right

	                                 JMP  EXIT_PLAYERS_MOVEMENT
			

	MOVE_SECOND_PLAYER_UP:           
	                                 MOV  AX,PLAYERS_VELOCITY
	                                 SUB  SECOND_PLAYER_Y,AX
				
	                                 MOV  AX,window_bounds_upper
	                                 CMP  SECOND_PLAYER_Y,AX
	                                 JL   FIX_second_player_TOP_POSITION
	                                 JMP  CHECK_FOR_COLLISION_2
				
	FIX_second_player_TOP_POSITION:  
	                                 MOV  SECOND_PLAYER_Y,AX
	                                 JMP  CHECK_FOR_COLLISION_2
			
	MOVE_SECOND_PLAYER_DOWN:         
	                                 MOV  AX,PLAYERS_VELOCITY
	                                 ADD  SECOND_PLAYER_Y,AX
	                                 MOV  AX,WINDOW_HEIGHT
	                                 SUB  AX,WINDOW_BOUNDS
	                                 SUB  AX,PLAYERS_HEIGHT
	                                 CMP  SECOND_PLAYER_Y,AX
	                                 JG   FIX_second_player_down_POSITION
	                                 JMP  CHECK_FOR_COLLISION_2
				
	FIX_second_player_down_POSITION: 
	                                 MOV  SECOND_PLAYER_Y,AX
	                                 JMP  CHECK_FOR_COLLISION_2


	MOVE_SECOND_PLAYER_left:         
	                                 MOV  AX,PLAYERS_VELOCITY
	                                 SUB  second_player_X,AX
	                                 MOV  AX,WINDOW_BOUNDS
	                                 CMP  second_player_X,AX
	                                 JL   FIX_SECOND_PLAYER_left_POSITION
	                                 JMP  CHECK_FOR_COLLISION_2
				
	FIX_SECOND_PLAYER_left_POSITION: 
	                                 MOV  second_player_X,AX
	                                 JMP  CHECK_FOR_COLLISION_2

	MOVE_SECOND_PLAYER_right:        
	                                 MOV  AX,PLAYERS_VELOCITY
	                                 ADD  second_player_X,AX
	                                 MOV  AX,WINDOW_WIDTH
	                                 SUB  AX,WINDOW_BOUNDS
	                                 sub  AX,PLAYERS_WIDTH
	                                 CMP  second_player_X,AX
	                                 JG   FIX_SECOND_PLAYER_RIGHT_POSITION
	                                 JMP  CHECK_FOR_COLLISION_2
	FIX_SECOND_PLAYER_RIGHT_POSITION:
	                                 MOV  second_player_X,AX
	                                 JMP  CHECK_FOR_COLLISION_2


	CHECK_FOR_COLLISION_2:           
	; maxx1 > minx2 && minx1 < maxx2 && maxy1 > miny2 && miny1 < maxy2
	                                 MOV  AX,first_player_X               	;IF maxx1 > minx2
	                                 ADD  AX,PLAYERS_WIDTH
	                                 CMP  AX,second_player_X
	                                 JNG  EXIT_PLAYERS_MOVEMENT           	;No collision will happen
		
	                                 MOV  AX,second_player_X              	;IF minx1 < maxx2
	                                 ADD  AX,PLAYERS_WIDTH
	                                 CMP  first_player_X,AX
	                                 JNL  EXIT_PLAYERS_MOVEMENT           	;No collision will happen
		
	                                 MOV  AX,SECOND_PLAYER_Y              	;IF maxy1 > miny2
	                                 ADD  AX,PLAYERS_HEIGHT
	                                 CMP  AX,first_player_Y
	                                 JNG  EXIT_PLAYERS_MOVEMENT           	;No collision will happen
		
	                                 MOV  AX,first_player_Y               	;IF  miny1 < maxy2
	                                 ADD  AX,PLAYERS_HEIGHT
	                                 CMP  SECOND_PLAYER_Y,AX
	                                 JNL  EXIT_PLAYERS_MOVEMENT           	;No collision will happen

	                                 MOV  DX,PRE_POSITION_X                	; If it reached here then there will be a collision
	                                 MOV  second_player_X,DX              	; Return the old values
	                                 MOV  DX,PRE_POSITION_Y
	                                 MOV  SECOND_PLAYER_Y,DX
									 RET

	EXIT_PLAYERS_MOVEMENT:
									Call FAR PTR Update_Players
									Call FAR PTR draw_p2


	RET
CHECK_SECOND_PLAYER_MOVEMENT ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;erase the player original position before moving
Update_Players PROC FAR
	
;;;;;;;;;;;;;;
    mov ah,0ch ;this means with int 10h ---> you're drawing a pixel
    mov al,background_color ;the pixel color
    mov bh,0  ;the page number
	MOV CX,PRE_POSITION_X
    MOV SI,CX
    ADD SI,PLAYERS_WIDTH
    ADD SI,1
	MOV Dx,PRE_POSITION_Y
    MOV DI,DX
    ADD DI,PLAYERS_HEIGHT
    ADD DI,1
    ;here we loop for 4/5 of the screen
    fillblue1:
        int 10h
        inc cx
        cmp cx,SI
        jnz fillblue1 ;if not zero so we continue to the same row 
        inc dx
        mov cx,PRE_POSITION_X
        cmp dx,DI ;if not zero so we continue to draw the background
        jnz fillblue1
    ;;;;;;;;;;;;;;

	RET
Update_Players ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


first_player_barriers_coli PROC FAR
                    ;check for collision between player1 and barriers(1,2)
      ;CHECK_FOR_COLLISION_p1_b1:          
	  mov First_Is_Collided,0
	                           ;first_player_x+players_width<x_barrier1
	                                 MOV  AX,first_player_X               	
	                                 ADD  AX,PLAYERS_WIDTH
	                                 CMP  AX,X_BARRIER1
	                                 JNG   CHECK_FOR_COLLISION_p1_b2            	;No collision will happen
		;first_player_x>x_barrier1+ BARRIER_HORIZONTAL_SIZE
	                                 MOV  AX,X_BARRIER1               	
	                                 ADD  AX, BARRIER_HORIZONTAL_SIZE
	                                 CMP  first_player_X,AX
	                                 JNL   CHECK_FOR_COLLISION_p1_b2         	;No collision will happen
		                   ;first_player_Y+players_HEIGHT<Y_barrier1
	                                 MOV  AX,First_PLAYER_Y              
	                                 ADD  AX,PLAYERS_HEIGHT
	                                 CMP  AX,Y_BARRIER1
	                                 JNG  CHECK_FOR_COLLISION_p1_b2           	;No collision will happen
		
	                        ;first_player_Y>Y_barrier1+ BARRIER_VERTICAL_SIZE
	                                 MOV  AX,Y_BARRIER1              
	                                 ADD  AX, BARRIER_VERTICAL_SIZE
	                                 CMP  first_player_Y,AX
	                                 JNL   CHECK_FOR_COLLISION_p1_b2         	;No collision will happen
                                    ;There is collision , set his state to collided and check if he has immunity to collision before decreasing health
                                    mov First_Is_Collided,1
							;check if he has immunity to collision
									cmp first_player_health_immunity , 0
									JZ Decrease_first_health_1
									JNZ Donot_Decrease_first_health_1 
									Decrease_first_health_1:	
															DEC first_player_health
							;give him immunity to not be affected by any barriers for this player
															MOV first_player_health_immunity,25
															CALL draw_h1
									Donot_Decrease_first_health_1:
									DEC first_player_health_immunity


CHECK_FOR_COLLISION_p1_b2:          
	                           ;first_player_x+players_width<x_barrier2
	                                 MOV  AX,first_player_X               	
	                                 ADD  AX,PLAYERS_WIDTH
	                                 CMP  AX,X_BARRIER2
	                                 JNG     EXIT_PLAYERS_barriers_col           	;No collision will happen
		;first_player_x>x_barrier2+ BARRIER_HORIZONTAL_SIZE
	                                 MOV  AX,X_BARRIER2               	
	                                 ADD  AX, BARRIER_HORIZONTAL_SIZE
	                                 CMP  first_player_X,AX
	                                 JNL      EXIT_PLAYERS_barriers_col      	;No collision will happen
		                           ;first_player_Y+players_HEIGHT<Y_barrier2
	                                 MOV  AX,First_PLAYER_Y              
	                                 ADD  AX,PLAYERS_HEIGHT
	                                 CMP  AX,Y_BARRIER2
	                                 JNG    EXIT_PLAYERS_barriers_col        	;No collision will happen
		
	                         ;first_player_Y>Y_barrier2+ BARRIER_VERTICAL_SIZE
	                                 MOV  AX,Y_BARRIER2              
	                                 ADD  AX, BARRIER_VERTICAL_SIZE
	                                 CMP  first_player_Y,AX
	                                 JNL      EXIT_PLAYERS_barriers_col         	;No collision will happen

                                     ;There is collision , set his state to collided and check if he has immunity to collision before decreasing health
                                    mov First_Is_Collided,1
							;check if he has immunity to collision
									cmp first_player_health_immunity , 0
									JZ Decrease_first_health_2
									JNZ Donot_Decrease_first_health_2 
									Decrease_first_health_2:	
															DEC first_player_health
							;give him immunity to not be affected by any barriers for this player
															MOV first_player_health_immunity,25
															CALL draw_h1
									Donot_Decrease_first_health_2:
									DEC first_player_health_immunity

   EXIT_PLAYERS_barriers_col:  
	                                 RET
first_player_barriers_coli ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

second_player_barriers_coli PROC FAR
                    ;;check for collision between player2 and barriers(1,2)


 CHECK_FOR_COLLISION_p2_b1:       
  mov Second_Is_Collided,0   
	                           ;second_player_x+players_width<x_barrier1
	                                 MOV  AX,second_player_X               	
	                                 ADD  AX,PLAYERS_WIDTH
	                                 CMP  AX,X_BARRIER1
	                                 JNG   CHECK_FOR_COLLISION_p2_b2            	;No collision will happen
		;second_player_x>x_barrier1+ BARRIER_HORIZONTAL_SIZE
	                                 MOV  AX,X_BARRIER1               	
	                                 ADD  AX, BARRIER_HORIZONTAL_SIZE
	                                 CMP  second_player_X,AX
	                                 JNL   CHECK_FOR_COLLISION_p2_b2         	;No collision will happen
		                           ;second_player_Y+players_HEIGHT<Y_barrier1
	                                 MOV  AX,second_PLAYER_Y              
	                                 ADD  AX,PLAYERS_HEIGHT
	                                 CMP  AX,Y_BARRIER1
	                                 JNG  CHECK_FOR_COLLISION_p2_b2          	;No collision will happen
		
	                         ;second_player_Y>Y_barrier1+ BARRIER_VERTICAL_SIZE
	                                 MOV  AX,Y_BARRIER1              
	                                 ADD  AX, BARRIER_VERTICAL_SIZE
	                                 CMP  second_player_Y,AX
	                                 JNL  CHECK_FOR_COLLISION_p2_b2         	;No collision will happen

    ;There is collision , set his state to collided and check if he has immunity to collision before decreasing health
                                    mov Second_Is_Collided,1
							;check if he has immunity to collision
									cmp second_player_health_immunity , 0
									JZ Decrease_second_health_1
									JNZ Donot_Decrease_second_health_1 
									Decrease_second_health_1:	
															DEC second_player_health
							;give him immunity to not be affected by any barriers for this player
															MOV second_player_health_immunity,25
															CALL draw_h2
									Donot_Decrease_second_health_1:
									DEC second_player_health_immunity

 CHECK_FOR_COLLISION_p2_b2:          
	                           ;second_player_x+players_width<x_barrier2
	                                 MOV  AX,second_player_X               	
	                                 ADD  AX,PLAYERS_WIDTH
	                                 CMP  AX,X_BARRIER2
	                                 JNG    EXIT2_PLAYERS_barriers_col          	;No collision will happen
		;second_player_x>x_barrier1+ BARRIER_HORIZONTAL_SIZE
	                                 MOV  AX,X_BARRIER2               	
	                                 ADD  AX, BARRIER_HORIZONTAL_SIZE
	                                 CMP  second_player_X,AX
	                                 JNL     EXIT2_PLAYERS_barriers_col         	;No collision will happen
		                           ;second_player_Y+players_HEIGHT<Y_barrier1
	                                 MOV  AX,second_PLAYER_Y              
	                                 ADD  AX,PLAYERS_HEIGHT
	                                 CMP  AX,Y_BARRIER2
	                                 JNG    EXIT2_PLAYERS_barriers_col         	;No collision will happen
		
	                         ;second_player_Y>Y_barrier1+ BARRIER_VERTICAL_SIZE
	                                 MOV  AX,Y_BARRIER2              
	                                 ADD  AX, BARRIER_VERTICAL_SIZE
	                                 CMP  second_player_Y,AX
	                                 JNL    EXIT2_PLAYERS_barriers_col        	;No collision will happen



    ;There is collision , set his state to collided and check if he has immunity to collision before decreasing health
                                    mov Second_Is_Collided,1
							;check if he has immunity to collision
									cmp second_player_health_immunity , 0
									JZ Decrease_second_health_2
									JNZ Donot_Decrease_second_health_2 
									Decrease_second_health_2:	
															DEC second_player_health
							;give him immunity to not be affected by any barriers for this player
															MOV second_player_health_immunity,25
															CALL draw_h2
									Donot_Decrease_second_health_2:
									DEC second_player_health_immunity
 
  EXIT2_PLAYERS_barriers_col:  
	                                 RET
second_player_barriers_coli ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CHECK_BOUNDARY_BARRIER1 PROC FAR

				
	                        MOV                 AX,X_BARRIER1
	                        CMP                 AX,SCREEN_MAX_X
	                        JE                  DONT_DRAW                  	;-> IF X==THE LAST ROW OF PIXELS THEN DONT DRAW
	                        MOV                 BX,SCREEN_MAX_X- BARRIER_HORIZONTAL_SIZE
	                        CMP                 BX,AX                      	;IF(BX>=AX) THEN NOTHING,,,,, ELSE -> THE BARRIER LENGTH WILL BE OUT OF THE SCREEN AND HAVE TO BE SHORTENED

	                        JAE                 GOOD_LENGTH
	                        MOV                 LENMAX,SCREEN_MAX_X

	GOOD_LENGTH:            
	                        MOV                 AX,Y_BARRIER1
	                        CMP                 AX,SCREEN_MAX_Y
	                        JE                  DONT_DRAW                  	;; IF Y== LAST COLUMN OF PIXELS THEN DONT DRAW
	                        MOV                 BX,SCREEN_MAX_Y- BARRIER_VERTICAL_SIZE
	                        CMP                 BX,AX                      	;IF(BX>=AX) THEN NOTHING,,,,, ELSE -> THE BARRIER WIDTH WILL BE OUT OF THE SCREEN AND HAVE TO BE SHORTENED
	                        JAE                 GOOD_WIDTH

	                        MOV                 WIDMAX,SCREEN_MAX_Y

	GOOD_WIDTH:             
	                                        
	                        CALL                FILLRECTANGLE

	DONT_DRAW:              
	                        RET
CHECK_BOUNDARY_BARRIER1 ENDP


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



CHECK_BOUNDARY_BARRIER2 PROC FAR

				
	                        MOV                 AX,X_BARRIER2
	                        CMP                 AX,SCREEN_MAX_X
	                        JE                  DONT_DRAW2                  	;-> IF X==THE LAST ROW OF PIXELS THEN DONT DRAW
	                        MOV                 BX,SCREEN_MAX_X- BARRIER_HORIZONTAL_SIZE
	;IF(BX>=AX) THEN NOTHING,,,,, ELSE -> THE BARRIER LENGTH WILL BE OUT OF THE SCREEN AND HAVE TO BE SHORTENED
	                        CMP                 BX,AX
	                        JAE                 GOOD_LENGTH2
	                        MOV                 LENMAX,SCREEN_MAX_X

	GOOD_LENGTH2:            
	                        MOV                 AX,Y_BARRIER2
	                        CMP                 AX,SCREEN_MAX_Y
	                        JE                  DONT_DRAW2                  	;; IF Y== LAST COLUMN OF PIXELS THEN DONT DRAW
	                        MOV                 BX,SCREEN_MAX_Y- BARRIER_VERTICAL_SIZE
	                        CMP                 BX,AX                      	;IF(BX>=AX) THEN NOTHING,,,,, ELSE -> THE BARRIER WIDTH WILL BE OUT OF THE SCREEN AND HAVE TO BE SHORTENED
	                        JAE                 GOOD_WIDTH2

	                        MOV                 WIDMAX,SCREEN_MAX_Y

	GOOD_WIDTH2:             
	                        CALL                FILLRECTANGLE

	DONT_DRAW2:              
	                        RET
CHECK_BOUNDARY_BARRIER2 ENDP


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CHECK_OVERLAPPING_BARRIER2 PROC FAR

	                               MOV                 AX,X_BARRIER2
	                               CMP                 AX,X_BARRIER1
	                               JGE                 CHECK_LESS_X1               ; if x2>= x1 then go check if x2 is less than x1+its length
	                               JMP                 END_CHECK_OVERLAPPING_BARRIER2
	CHECK_LESS_X1:                 
	                               MOV                 AX,X_BARRIER1
	                               ADD                 AX, BARRIER_HORIZONTAL_SIZE
	                               MOV                 BX,X_BARRIER2
	                               CMP                 BX,AX
	                               JLE                 X2_OVERLAPS                               ;this means it overlaps
	                               JMP                 END_CHECK_OVERLAPPING_BARRIER2
	X2_OVERLAPS:  ;if barrier 2 overlaps with barrier 1,make barrier2 start at the end of barrier1                   
	                               MOV                 AX,X_BARRIER1
	                               ADD                 AX, BARRIER_HORIZONTAL_SIZE
	                               MOV                 X_BARRIER2,AX
	


	END_CHECK_OVERLAPPING_BARRIER2:
	                               RET
CHECK_OVERLAPPING_BARRIER2 ENDP


ERASE_RECTANGLE proc FAR

                            ;MOV DI,0
	                        PUSH                LEN
	ERASE:                   
	                        PUSH                LEN
	ERASEINNER:              


	                        MOV                 AH,0CH
	                        MOV                 AL,background_color
							INC                 DI
	                        MOV                 BH,0H
    
	                        MOV                 CX,LEN
	                        MOV                 DX,WID
	                        INT                 10H

	                        MOV                 BX,LENMAX
	                        INC                 LEN
	                        CMP                 BX,LEN
	                        JNZ                 ERASEINNER
	                        POP                 LEN

	                        INC                 WID
	                        MOV                 BX,WIDMAX
	                        CMP                 BX,WID
	                        JNZ                 ERASE

	                        POP                 WID
	                        RET
ERASE_RECTANGLE ENDP




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;MOVING BARRIER 1,2 for level_1
;MOVING BARRIER 1,2 
MOVE_BARRIERS PROC FAR
												;; DELETE THE OLD BARRIER1 BEFORE DRAWING IT IN THE NEW POSITION
												MOV AX,X_BARRIER1
												MOV LEN,AX	
												ADD AX,BARRIER_HORIZONTAL_SIZE
												MOV LENMAX,AX	
												MOV AX,Y_BARRIER1
												MOV WID,AX
												ADD AX,BARRIER_VERTICAL_SIZE	
												MOV WIDMAX,AX
												CALL  ERASE_RECTANGLE

												;; DELETE THE OLD BARRIER1 BEFORE DRAWING IT IN THE NEW POSITION
												MOV AX,X_BARRIER2
												MOV LEN,AX	
												ADD AX,BARRIER_HORIZONTAL_SIZE
												MOV LENMAX,AX	
												MOV AX,Y_BARRIER2
												MOV WID,AX
												ADD AX,BARRIER_VERTICAL_SIZE	
												MOV WIDMAX,AX
												CALL  ERASE_RECTANGLE


												MOV AX,x_barrier1
												MOV PRE_POSITION_X,AX
												MOV AX,Y_barrier1
												MOV PRE_POSITION_Y,AX

												MOV AX,x_barrier2
												MOV PRE_POSITION_X2,AX
												MOV AX,Y_barrier2
												MOV PRE_POSITION_Y2,AX
											
												CHECK_BARRIER1_TOP:			;check if barrier1 reach top of page(before reaching health bar)
																	CMP Y_BARRIER1 ,24 			                            
																	JLE BARRIER_1_REACHED_TOP
																	JG BARRIERS_1_DIDNT_REACH_TOP

												BARRIER_1_REACHED_TOP: 		;If reached top of page return it to the bottom
																	 Mov Y_BARRIER1,Initial_Y_Barrier1
																	 ;Change the X-position of the Barrier
																	check_x1:
																				CMP X_BARRIER1,260;10<=x_barrier_1<= 260  
																				JGE X1_REACH_MAX 
																				JL X1_DONT_REACH_MAX                  
														
																	X1_REACH_MAX:
																				SUB X_BARRIER1,200
																				JMP CHECK_BARRIER2_TOP

																	X1_DONT_REACH_MAX:
																					ADD X_BARRIER1,50  ;;10-->60-->120.....--->260
																					JMP CHECK_BARRIER2_TOP

												BARRIERS_1_DIDNT_REACH_TOP:		;moving barriers up
																	SUB Y_Barrier1,1		;5 steps by which the barriers are moving
												
												CHECK_BARRIER2_TOP: 		;check if barrier2 reach top of page(before reaching health bar)
																	CMP Y_BARRIER2 ,24 			                            
																	JLE BARRIER_2_REACHED_TOP
																	JG BARRIERS_2_DIDNT_REACH_TOP

												BARRIER_2_REACHED_TOP: 
																	 Mov Y_BARRIER2,Initial_Y_Barrier2
																	 ;Randomize the X-position of the Barrier
																	check_x2:
																			CMP X_BARRIER2,10;10<=x_barrier_1<= 260  
																			JLE X2_REACH_MAX 
																			JG X2_DONT_REACH_MAX                  
														
																	X2_REACH_MAX:
																				ADD X_BARRIER2,200	
																				JMP X_TEMP_LABEL1

																	X2_DONT_REACH_MAX:
																					SUB X_BARRIER2,50	;;260-->210-->...-->10
																					JMP X_TEMP_LABEL1
																						

												BARRIERS_2_DIDNT_REACH_TOP:		;moving barriers up
																	SUB Y_Barrier2,2		;5 steps by which the barriers are moving
												
												

												X_TEMP_LABEL1:		
												CALL first_player_barriers_coli
												CALL second_player_barriers_coli
												CALL draw_p1
												CALL draw_p2
												CALL DRAW_BARRIER1
												CALL DRAW_BARRIER2

							RET
												
MOVE_BARRIERS ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;MOVING BARRIER 1,2 for level_2
MOVE_BARRIERS_2 PROC FAR
												;; DELETE THE OLD BARRIER1 BEFORE DRAWING IT IN THE NEW POSITION
												MOV AX,X_BARRIER1
												MOV LEN,AX	
												ADD AX,BARRIER_HORIZONTAL_SIZE
												MOV LENMAX,AX	
												MOV AX,Y_BARRIER1
												MOV WID,AX
												ADD AX,BARRIER_VERTICAL_SIZE	
												MOV WIDMAX,AX
												CALL  ERASE_RECTANGLE

												;; DELETE THE OLD BARRIER1 BEFORE DRAWING IT IN THE NEW POSITION
												MOV AX,X_BARRIER2
												MOV LEN,AX	
												ADD AX,BARRIER_HORIZONTAL_SIZE
												MOV LENMAX,AX	
												MOV AX,Y_BARRIER2
												MOV WID,AX
												ADD AX,BARRIER_VERTICAL_SIZE	
												MOV WIDMAX,AX
												CALL  ERASE_RECTANGLE


												MOV AX,x_barrier1
												MOV PRE_POSITION_X,AX
												MOV AX,Y_barrier1
												MOV PRE_POSITION_Y,AX

												MOV AX,x_barrier2
												MOV PRE_POSITION_X2,AX
												MOV AX,Y_barrier2
												MOV PRE_POSITION_Y2,AX
											
												CHECK_BARRIER1_TOP_2:			;check if barrier1 reach top of page(before reaching health bar)
																	CMP Y_BARRIER1 ,24 			                            
																	JLE BARRIER_1_REACHED_TOP_2
																	JG BARRIERS_1_DIDNT_REACH_TOP_2

												BARRIER_1_REACHED_TOP_2: 		;If reached top of page return it to the bottom
																	 Mov Y_BARRIER1,Initial_Y_Barrier1
																	 ;Change the X-position of the Barrier
																

												BARRIERS_1_DIDNT_REACH_TOP_2:		;moving barriers up
																	SUB Y_Barrier1,1		;5 steps by which the barriers are moving


                                                                    	check_x1_2:
																				CMP X_BARRIER1,260;10<=x_barrier_1<= 260  
																				JGE X1_REACH_MAX_2 
																				JL X1_DONT_REACH_MAX_2                  
														
																	X1_REACH_MAX_2:
																				SUB X_BARRIER1,200
																				JMP CHECK_BARRIER2_TOP_2

																	X1_DONT_REACH_MAX_2:
																					ADD X_BARRIER1,2  ;;10-->60-->120.....--->260
																					JMP CHECK_BARRIER2_TOP_2

												
												CHECK_BARRIER2_TOP_2: 		;check if barrier2 reach top of page(before reaching health bar)
																	CMP Y_BARRIER2 ,24 			                            
																	JLE BARRIER_2_REACHED_TOP_2
																	JG BARRIERS_2_DIDNT_REACH_TOP_2

												BARRIER_2_REACHED_TOP_2: 
																	 Mov Y_BARRIER2,Initial_Y_Barrier2
																	 ;Randomize the X-position of the Barrier
																
																						

												BARRIERS_2_DIDNT_REACH_TOP_2:		;moving barriers up
																	SUB Y_Barrier2,2		;5 steps by which the barriers are moving
												
													check_x2_2:
																			CMP X_BARRIER2,10;10<=x_barrier_1<= 260  
																			JLE X2_REACH_MAX_2 
																			JG X2_DONT_REACH_MAX_2                  
														
																	X2_REACH_MAX_2:
																				ADD X_BARRIER2,200	
																				JMP X_TEMP_LABEL_2

																	X2_DONT_REACH_MAX_2:
																					SUB X_BARRIER2,1	;;260-->210-->...-->10
																					JMP X_TEMP_LABEL_2



												X_TEMP_LABEL_2:		
												CALL first_player_barriers_coli
												CALL second_player_barriers_coli
												CALL draw_p1
												CALL draw_p2
												CALL DRAW_BARRIER1
												CALL DRAW_BARRIER2

							RET
												
MOVE_BARRIERS_2 ENDP





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;This function is to draw the Red Laser from Left to Right (Just a colored line from start to end)

Draw_RED_LASER_LEFT_TO_RIGHT PROC FAR

		mov ah,0ch                          	;this means with int 10h ---> you're drawing a pixel

		mov cx,Red_Laser_Start_X
		mov dx,first_player_Y
		add dx,Player_Shooter_Y_Offset
		
	Continue_Red_LASER_1:

		mov al,RED
		Int 10h

		INC dx
		mov al, Yellow
		INT 10h

		INC dx
		mov al, Yellow
		INT 10h
		
		INC dx
		mov al, Red
		INT 10h

		cmp cx,Red_Laser_End_X 
		jz END_Draw_Red_Laser_1
		inc cx
		Sub dx,3
		jmp Continue_Red_LASER_1
		
		End_Draw_Red_Laser_1:

		mov cx,0ffffh
		wait1: 
			
		DEC CX
		CMP CX,0
		JNE wait1

		mov cx,Red_Laser_Start_X
		mov dx,first_player_Y
		add dx,Player_Shooter_Y_Offset
		

	Clear_Red_Laser_1:
		mov al,background_color
		Int 10h

		INC dx
		mov al, background_color
		INT 10h

		INC dx
		mov al, background_color
		INT 10h
		
		INC dx
		mov al, background_color
		INT 10h

		cmp cx,Red_Laser_End_X 
		jz END_Red_Laser_1
		inc cx
		Sub dx,3
		jmp Clear_Red_LASER_1
		

    END_Red_Laser_1:


	RET
Draw_RED_LASER_LEFT_TO_RIGHT ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;This function is to draw the Red Laser from Right to Left	(Just a colored line from start to end)


Draw_RED_LASER_RIGHT_TO_LEFT PROC 
	

		mov ah,0ch                          	;this means with int 10h ---> you're drawing a pixel

		mov cx,Red_Laser_Start_X
		mov dx,first_player_Y
		add dx,Player_Shooter_Y_Offset
		
	Continue_Red_LASER_2:

		mov al,RED
		Int 10h

		INC dx
		mov al, Yellow
		INT 10h

		INC dx
		mov al, Yellow
		INT 10h
		
		INC dx
		mov al, Red
		INT 10h

		cmp cx,Red_Laser_End_X 
		jz END_Draw_Red_Laser_2
		dec cx
		Sub dx,3
		jmp Continue_Red_LASER_2
		

		END_Draw_Red_Laser_2:
		mov cx,0ffffh
		wait2: 
			
		DEC CX
		CMP CX,0
		JNE wait2


		mov cx,Red_Laser_Start_X
		mov dx,first_player_Y
		add dx,Player_Shooter_Y_Offset
	
		Clear_Red_LASER_2:

		mov al,background_color
		Int 10h

		INC dx
		mov al, background_color
		INT 10h

		INC dx
		mov al, background_color
		INT 10h
		
		INC dx
		mov al, background_color
		INT 10h

		cmp cx,Red_Laser_End_X 
		jz END_Red_Laser_2
		dec cx
		Sub dx,3
		jmp Clear_Red_LASER_2




    END_Red_Laser_2:

	RET
Draw_RED_LASER_RIGHT_TO_LEFT ENDP


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;This function is to draw the Blue Laser from Left to Right	(Just a colored line from start to end)


Draw_BLUE_LASER_LEFT_TO_RIGHT PROC 
	
		mov ah,0ch                          	;this means with int 10h ---> you're drawing a pixel

		mov cx,Blue_Laser_Start_X
		mov dx,Second_player_Y
		add dx,Player_Shooter_Y_Offset
		
	Continue_Blue_LASER_1:

		mov al,Dark_Blue
		Int 10h

		INC dx
		mov al, Light_Blue
		INT 10h

		INC dx
		mov al, Light_Blue
		INT 10h
		
		INC dx
		mov al, Dark_Blue
		INT 10h

		cmp cx,Blue_Laser_End_X 
		jz END_Draw_Blue_Laser_1
		inc cx
		Sub dx,3
		jmp Continue_Blue_LASER_1


		END_Draw_Blue_Laser_1:

		mov cx,0ffffh
			wait3: 
			
		DEC CX
		CMP CX,0
		JNE wait3


		mov cx,Blue_Laser_Start_X
		mov dx,Second_player_Y
		add dx,Player_Shooter_Y_Offset
		
	Clear_Blue_LASER_1:

		mov al,background_color
		Int 10h

		INC dx
		mov al, background_color
		INT 10h

		INC dx
		mov al, background_color
		INT 10h
		
		INC dx
		mov al, background_color
		INT 10h

		cmp cx,Blue_Laser_End_X 
		jz END_Blue_Laser_1
		inc cx
		Sub dx,3
		jmp Clear_Blue_LASER_1




    END_Blue_Laser_1:


	RET
Draw_BLUE_LASER_LEFT_TO_RIGHT ENDP


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;This function is to draw the Blue Laser from Right to Left	(Just a colored line from start to end)

Draw_BLUE_LASER_RIGHT_TO_LEFT PROC 
		
		mov ah,0ch                          	;this means with int 10h ---> you're drawing a pixel

		mov cx,Blue_Laser_Start_X
		mov dx,Second_player_Y
		add dx,Player_Shooter_Y_Offset
		
		
	Continue_Blue_LASER_2:

		mov al,Dark_Blue
		Int 10h

		INC dx
		mov al, Light_Blue
		INT 10h

		INC dx
		mov al, Light_Blue
		INT 10h
		
		INC dx
		mov al, Dark_Blue
		INT 10h

		cmp cx,Blue_Laser_End_X 
		jz END_Draw_Blue_Laser_2
		dec cx
		Sub dx,3
		jmp Continue_Blue_LASER_2


	End_Draw_Blue_Laser_2:
	mov cx,0ffffh
		wait4: 
			
		DEC CX
		CMP CX,0
		JNE wait4

		mov cx,Blue_Laser_Start_X
		mov dx,Second_player_Y
		add dx,Player_Shooter_Y_Offset
		
		
	Clear_Blue_LASER_2:

		mov al,background_color
		Int 10h

		INC dx
		mov al, background_color
		INT 10h

		INC dx
		mov al, background_color
		INT 10h
		
		INC dx
		mov al, background_color
		INT 10h

		cmp cx,Blue_Laser_End_X 
		jz END_Blue_Laser_2
		dec cx
		Sub dx,3
		jmp Clear_Blue_LASER_2




    END_Blue_Laser_2:


	RET
Draw_BLUE_LASER_RIGHT_TO_LEFT ENDP


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;This function is to make the first Player attack from Left to Right
First_Attack_Left_TO_Right PROC FAR

		;First we set the coordinates for the drawing 
		mov ax,first_player_X
		Add ax,PLAYERS_WIDTH
		mov Red_Laser_Start_X,Ax

		;git the first thing that will hit the laser
		mov bx,WINDOW_WIDTH  					;BX will contain the end of the laser for the rest of the function
		sub bx,2

		;check the barriers, first ask if it is in the same Y Area, then ask for the X area
		; 					   *----------------------------			|
		; ------------*		   |	Barrier	At Right		|			|
		; |At left:	|		   |							|			|	The window wall
		; |	Beam 	|          |     						|			|
		; ------------*		   |							|			|
		; 					   *-----------------------------			|
		Red_Laser1_Colli_First_Barrier:
		mov dx,First_player_Y
		add dx,Player_Shooter_Y_Offset ;now the dx has the Red Laser Start Y
		add dx,LASER_SIZE                      ;dx --->the laser ending Y
		cmp dx,Y_barrier1
		JL Red_Laser1_Colli_Second_Barrier    ;all the Y of the laser < starting Y of the Barrier--> No collision
		
		sub dx,LASER_SIZE					   ;now the dx has the Red Laser Start Y
		mov cx,Y_barrier1			   
		add cx,BARRIER_VERTICAL_SIZE    ;now cx has the last Y of the Barrier
		cmp dx,cx
		JG Red_Laser1_Colli_Second_Barrier	;all the Y of the laser > ending Y of the Barrier--> No collision

		;;;;If it reached here then, there will be a collision in the Y,check for X
		mov ax, Red_Laser_Start_X
		cmp ax,X_BARRIER1					;Check the Barrier Position relative to the Player
		JGE Red_Laser1_Colli_Second_Barrier  ;The Barrier is Behind the player (if player is collided with the barrier we won't fire )
		mov ax,X_BARRIER1                   ;when reached here, it means that the Barrier Will block my way. But is it the first thing to block ?
		cmp ax,bx							
		JG Red_Laser1_Colli_Second_Barrier  ;if this new AX(X_Barrier) > BX ---> Then it's not the first thing to Block my way

		mov bx,ax




		;check the second barrier
		Red_Laser1_Colli_Second_Barrier:
		mov dx,First_player_Y
		add dx,Player_Shooter_Y_Offset ;now the dx has the Red Laser Start Y
		add dx,LASER_SIZE                      ;dx --->the laser ending Y
		cmp dx,Y_barrier2
		JL Red_Laser1_Colli_Second_Player    ;all the Y of the laser < starting Y of the Barrier--> No collision
		
		sub dx,LASER_SIZE					   ;now the dx has the Red Laser Start Y
		mov cx,Y_barrier2			   
		add cx,BARRIER_VERTICAL_SIZE    ;now cx has the last Y of the Barrier
		cmp dx,cx
		JG Red_Laser1_Colli_Second_Player	;all the Y of the laser > ending Y of the Barrier--> No collision

		;;;;If it reached here then, there will be a collision in the Y,check for X
		mov ax, Red_Laser_Start_X
		cmp ax,X_BARRIER2					;Check the Barrier Position relative to the Player
		JGE Red_Laser1_Colli_Second_Player  ;The Barrier is Behind the player (if player is collided with the barrier we won't fire )
		mov ax,X_BARRIER2                   ;when reached here, it means that the Barrier Will block my way. But is it the first thing to block ?
		cmp ax,bx							
		JG Red_Laser1_Colli_Second_Player  ;if this new AX(X_Barrier) > BX ---> Then it's not the first thing to Block my way

		mov bx,ax





		;check the blue player

		Red_Laser1_Colli_Second_Player:
		mov dx,First_player_Y
		add dx,Player_Shooter_Y_Offset ;now the dx has the Red Laser Start Y
		add dx,LASER_SIZE                      ;dx --->the laser ending Y
		cmp dx,Second_player_Y
		JL Finish_First_Attack_Left_TO_Right    ;all the Y of the laser < starting Y of the Second Player--> No collision
		
		sub dx,LASER_SIZE					   ;now the dx has the Red Laser Start Y
		mov cx,Second_player_Y			   
		add cx,PLAYERS_HEIGHT    ;now cx has the last Y of the Player
		cmp dx,cx
		JG Finish_First_Attack_Left_TO_Right	;all the Y of the laser > ending Y of the Player--> No collision

		;;;;If it reached here then, there will be a collision in the Y,check for X
		mov ax, Red_Laser_Start_X
		cmp ax,second_player_X					;Check the Second Player Position relative to the Player
		JGE Finish_First_Attack_Left_TO_Right  ;The Second Player is Behind the player (if player is collided with the barrier we won't fire )
		mov ax,Second_player_X                   ;when reached here, it means that the Second Player Will block my way. But is it the first thing to block ?
		cmp ax,bx							
		JG Finish_First_Attack_Left_TO_Right  ;if this new AX(second_player_X) > BX ---> Then it's not the first thing to Block my way

		mov bx,ax
		mov second_player_Freeze,25				;make the second player freeze




Finish_First_Attack_Left_TO_Right:

mov Red_Laser_End_X,bx
Call Draw_RED_LASER_LEFT_TO_RIGHT
RET
First_Attack_Left_TO_Right ENDP



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;This function is to make the first Player attack from Left to Right
First_Attack_Right_TO_Left PROC FAR

		;First we set the coordinates for the drawing 
		mov ax,first_player_X
		mov Red_Laser_Start_X,Ax

		;git the first thing that will hit the laser
		mov bx,2  					;BX will contain the end of the laser for the rest of the function

		;check the barriers, first ask if it is in the same Y Area, then ask for the X area
		;	 	|		   ----------------------------*
		;The 	|		   |	Barrier	At Left			|	*------------		
		;Window	|		   |							|	|At Right:	|			
		;Wall	|          |     						|	|	Beam 	| 		
		; 	 	|		   |							|	*------------		
		; 	 	|		   -----------------------------*
		Red_Laser2_Colli_First_Barrier:
		mov dx,First_player_Y
		add dx,Player_Shooter_Y_Offset ;now the dx has the Red Laser Start Y
		add dx,LASER_SIZE                      ;dx --->the laser ending Y
		cmp dx,Y_barrier1
		JL Red_Laser2_Colli_Second_Barrier    ;all the Y of the laser < starting Y of the Barrier--> No collision
		
		sub dx,LASER_SIZE					   ;now the dx has the Red Laser Start Y
		mov cx,Y_barrier1			   
		add cx,BARRIER_VERTICAL_SIZE    ;now cx has the last Y of the Barrier
		cmp dx,cx
		JG Red_Laser2_Colli_Second_Barrier	;all the Y of the laser > ending Y of the Barrier--> No collision

		;;;;If it reached here then, there will be a collision in the Y,check for X
		mov ax, Red_Laser_Start_X
		mov dx,X_Barrier1
		Add dx,BARRIER_HORIZONTAL_SIZE		;now dx has the right most X_Position of the Barrier
		cmp ax,DX							;Check the Barrier Position relative to the Player
		JLE Red_Laser2_Colli_Second_Barrier  ;The Barrier is Behind the player (if player is collided with the barrier we won't fire )
		mov ax,X_BARRIER1                   ;when reached here, it means that the Barrier Will block my way. But is it the first thing to block ?
		ADD ax,BARRIER_HORIZONTAL_SIZE
		cmp ax,bx							
		JL Red_Laser2_Colli_Second_Barrier  ;if this new AX(X_Barrier) < BX ---> Then it's not the first thing to Block my way

		mov bx,ax




		;check the second barrier
		Red_Laser2_Colli_Second_Barrier:
		mov dx,First_player_Y
		add dx,Player_Shooter_Y_Offset ;now the dx has the Red Laser Start Y
		add dx,LASER_SIZE                      ;dx --->the laser ending Y
		cmp dx,Y_barrier2
		JL Red_Laser2_Colli_Second_Player    ;all the Y of the laser < starting Y of the Barrier--> No collision
		
		sub dx,LASER_SIZE					   ;now the dx has the Red Laser Start Y
		mov cx,Y_barrier2			   
		add cx,BARRIER_VERTICAL_SIZE    ;now cx has the last Y of the Barrier
		cmp dx,cx
		JG Red_Laser2_Colli_Second_Player	;all the Y of the laser > ending Y of the Barrier--> No collision

		;;;;If it reached here then, there will be a collision in the Y,check for X
		mov ax, Red_Laser_Start_X
		mov dx,X_BARRIER2
		Add dx,BARRIER_HORIZONTAL_SIZE		;now dx has the right most X_Position of the Barrier
		cmp ax,DX							;Check the Barrier Position relative to the Player
		JLE Red_Laser2_Colli_Second_Player  ;The Barrier is Behind the player (if player is collided with the barrier we won't fire )
		mov ax,X_BARRIER2                   ;when reached here, it means that the Barrier Will block my way. But is it the first thing to block ?
		ADD ax,BARRIER_HORIZONTAL_SIZE
		cmp ax,bx							
		JL Red_Laser2_Colli_Second_Player  ;if this new AX(X_Barrier) > BX ---> Then it's not the first thing to Block my way

		mov bx,ax





		;check the blue player

		Red_Laser2_Colli_Second_Player:
		mov dx,First_player_Y
		add dx,Player_Shooter_Y_Offset ;now the dx has the Red Laser Start Y
		add dx,LASER_SIZE                      ;dx --->the laser ending Y
		cmp dx,Second_player_Y
		JL Finish_First_Attack_Right_TO_Left    ;all the Y of the laser < starting Y of the Second Player--> No collision
		
		sub dx,LASER_SIZE					   ;now the dx has the Red Laser Start Y
		mov cx,Second_player_Y			   
		add cx,PLAYERS_HEIGHT    ;now cx has the last Y of the Player
		cmp dx,cx
		JG Finish_First_Attack_Right_TO_Left	;all the Y of the laser > ending Y of the Player--> No collision

		;;;;If it reached here then, there will be a collision in the Y,check for X
		mov ax, Red_Laser_Start_X
		mov dx,second_player_X
		ADD dx,PLAYERS_WIDTH
		cmp ax,DX								;Check the Second Player Position relative to the Player
		JLE Finish_First_Attack_Right_TO_Left  ;The Second Player is Behind the player (if player is collided with the barrier we won't fire )
		mov ax,Second_player_X                   ;when reached here, it means that the Second Player Will block my way. But is it the first thing to block ?
		add ax,PLAYERS_WIDTH
		cmp ax,bx							
		JL Finish_First_Attack_Right_TO_Left  ;if this new AX(second_player_X) > BX ---> Then it's not the first thing to Block my way

		mov bx,ax
		mov second_player_Freeze,25				;make the second player freeze




Finish_First_Attack_Right_TO_Left:

mov Red_Laser_End_X,bx
Call Draw_RED_LASER_Right_TO_Left
RET
First_Attack_Right_TO_Left ENDP



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;This function is to make the Second Player attack from Left to Right
Second_Attack_Left_TO_Right PROC FAR

		;First we set the coordinates for the drawing 
		mov ax,Second_player_X
		Add ax,PLAYERS_WIDTH
		mov Blue_Laser_Start_X,Ax

		;git the first thing that will hit the laser
		mov bx,WINDOW_WIDTH  					;BX will contain the end of the laser for the rest of the function
		sub bx,2

		;check the barriers, first ask if it is in the same Y Area, then ask for the X area
		; 					   *----------------------------			|
		; ------------*		   |	Barrier	At Right		|			|
		; |At left:	|		   |							|			|	The window wall
		; |	Beam 	|          |     						|			|
		; ------------*		   |							|			|
		; 					   *-----------------------------			|
		Blue_Laser1_Colli_First_Barrier:
		mov dx,Second_player_Y
		add dx,Player_Shooter_Y_Offset ;now the dx has the BLUE Laser Start Y
		add dx,LASER_SIZE                      ;dx --->the laser ending Y
		cmp dx,Y_barrier1
		JL Blue_Laser1_Colli_Second_Barrier    ;all the Y of the laser < starting Y of the Barrier--> No collision
		
		sub dx,LASER_SIZE					   ;now the dx has the BLUE Laser Start Y
		mov cx,Y_barrier1			   
		add cx,BARRIER_VERTICAL_SIZE    ;now cx has the last Y of the Barrier
		cmp dx,cx
		JG Blue_Laser1_Colli_Second_Barrier	;all the Y of the laser > ending Y of the Barrier--> No collision

		;;;;If it reached here then, there will be a collision in the Y,check for X
		mov ax, Blue_Laser_Start_X
		cmp ax,X_BARRIER1					;Check the Barrier Position relative to the Player
		JGE Blue_Laser1_Colli_Second_Barrier  ;The Barrier is Behind the player (if player is collided with the barrier we won't fire )
		mov ax,X_BARRIER1                   ;when reached here, it means that the Barrier Will block my way. But is it the first thing to block ?
		cmp ax,bx							
		JG Blue_Laser1_Colli_Second_Barrier  ;if this new AX(X_Barrier) > BX ---> Then it's not the first thing to Block my way

		mov bx,ax




		;check the second barrier
		Blue_Laser1_Colli_Second_Barrier:
		mov dx,Second_player_Y
		add dx,Player_Shooter_Y_Offset ;now the dx has the BLUE Laser Start Y
		add dx,LASER_SIZE                      ;dx --->the laser ending Y
		cmp dx,Y_barrier2
		JL Blue_Laser1_Colli_first_Player    ;all the Y of the laser < starting Y of the Barrier--> No collision
		
		sub dx,LASER_SIZE					   ;now the dx has the BLUE Laser Start Y
		mov cx,Y_barrier2			   
		add cx,BARRIER_VERTICAL_SIZE    ;now cx has the last Y of the Barrier
		cmp dx,cx
		JG Blue_Laser1_Colli_first_Player	;all the Y of the laser > ending Y of the Barrier--> No collision

		;;;;If it reached here then, there will be a collision in the Y,check for X
		mov ax, Blue_Laser_Start_X
		cmp ax,X_BARRIER2					;Check the Barrier Position relative to the Player
		JGE Blue_Laser1_Colli_First_Player  ;The Barrier is Behind the player (if player is collided with the barrier we won't fire )
		mov ax,X_BARRIER2                   ;when reached here, it means that the Barrier Will block my way. But is it the first thing to block ?
		cmp ax,bx							
		JG Blue_Laser1_Colli_First_Player  ;if this new AX(X_Barrier) > BX ---> Then it's not the first thing to Block my way

		mov bx,ax





		;check the BLUE player

		Blue_Laser1_Colli_First_Player:
		mov dx,Second_player_Y
		add dx,Player_Shooter_Y_Offset ;now the dx has the BLUE Laser Start Y
		add dx,LASER_SIZE                      ;dx --->the laser ending Y
		cmp dx,First_player_Y
		JL Finish_Second_Attack_Left_TO_Right    ;all the Y of the laser < starting Y of the Second Player--> No collision
		
		sub dx,LASER_SIZE					   ;now the dx has the BLUE Laser Start Y
		mov cx,first_player_Y			   
		add cx,PLAYERS_HEIGHT    ;now cx has the last Y of the Player
		cmp dx,cx
		JG Finish_Second_Attack_Left_TO_Right	;all the Y of the laser > ending Y of the Player--> No collision

		;;;;If it reached here then, there will be a collision in the Y,check for X
		mov ax, Blue_Laser_Start_X
		cmp ax,First_player_X					;Check the Second Player Position relative to the Player
		JGE Finish_Second_Attack_Left_TO_Right  ;The Second Player is Behind the player (if player is collided with the barrier we won't fire )
		mov ax,first_player_X                   ;when reached here, it means that the Second Player Will block my way. But is it the first thing to block ?
		cmp ax,bx							
		JG Finish_Second_Attack_Left_TO_Right  ;if this new AX(second_player_X) > BX ---> Then it's not the first thing to Block my way

		mov bx,ax
		mov First_player_Freeze,25				;make the first player freeze




Finish_Second_Attack_Left_TO_Right:

mov Blue_Laser_End_X,bx
Call Draw_Blue_LASER_LEFT_TO_RIGHT
RET
Second_Attack_Left_TO_Right ENDP



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;This function is to make the Second Player attack from Left to Right
Second_Attack_Right_TO_Left PROC FAR

		;First we set the coordinates for the drawing 
		mov ax,Second_player_X
		mov Blue_Laser_Start_X,Ax

		;git the first thing that will hit the laser
		mov bx,2  					;BX will contain the end of the laser for the rest of the function

		;check the barriers, first ask if it is in the same Y Area, then ask for the X area
		;	 	|		   ----------------------------*
		;The 	|		   |	Barrier	At Left			|	*------------		
		;Window	|		   |							|	|At Right:	|			
		;Wall	|          |     						|	|	Beam 	| 		
		; 	 	|		   |							|	*------------		
		; 	 	|		   -----------------------------*
		Blue_Laser2_Colli_First_Barrier:
		mov dx,Second_player_Y
		add dx,Player_Shooter_Y_Offset ;now the dx has the BLUE Laser Start Y
		add dx,LASER_SIZE                      ;dx --->the laser ending Y
		cmp dx,Y_barrier1
		JL Blue_Laser2_Colli_Second_Barrier    ;all the Y of the laser < starting Y of the Barrier--> No collision
		
		sub dx,LASER_SIZE					   ;now the dx has the BLUE Laser Start Y
		mov cx,Y_barrier1			   
		add cx,BARRIER_VERTICAL_SIZE    ;now cx has the last Y of the Barrier
		cmp dx,cx
		JG Blue_Laser2_Colli_Second_Barrier	;all the Y of the laser > ending Y of the Barrier--> No collision

		;;;;If it reached here then, there will be a collision in the Y,check for X
		mov ax, Blue_Laser_Start_X
		mov dx,X_Barrier1
		Add dx,BARRIER_HORIZONTAL_SIZE		;now dx has the right most X_Position of the Barrier
		cmp ax,DX							;Check the Barrier Position relative to the Player
		JLE Blue_Laser2_Colli_Second_Barrier  ;The Barrier is Behind the player (if player is collided with the barrier we won't fire )
		mov ax,X_BARRIER1                   ;when reached here, it means that the Barrier Will block my way. But is it the first thing to block ?
		ADD ax,BARRIER_HORIZONTAL_SIZE
		cmp ax,bx							
		JL Blue_Laser2_Colli_Second_Barrier  ;if this new AX(X_Barrier) < BX ---> Then it's not the first thing to Block my way

		mov bx,ax




		;check the second barrier
		Blue_Laser2_Colli_Second_Barrier:
		mov dx,Second_player_Y
		add dx,Player_Shooter_Y_Offset ;now the dx has the BLUE Laser Start Y
		add dx,LASER_SIZE                      ;dx --->the laser ending Y
		cmp dx,Y_barrier2
		JL Blue_Laser2_Colli_First_Player    ;all the Y of the laser < starting Y of the Barrier--> No collision
		
		sub dx,LASER_SIZE					   ;now the dx has the BLUE Laser Start Y
		mov cx,Y_barrier2			   
		add cx,BARRIER_VERTICAL_SIZE    ;now cx has the last Y of the Barrier
		cmp dx,cx
		JG Blue_Laser2_Colli_First_Player	;all the Y of the laser > ending Y of the Barrier--> No collision

		;;;;If it reached here then, there will be a collision in the Y,check for X
		mov ax, Blue_Laser_Start_X
		mov dx,X_BARRIER2
		Add dx,BARRIER_HORIZONTAL_SIZE		;now dx has the right most X_Position of the Barrier
		cmp ax,DX							;Check the Barrier Position relative to the Player
		JLE Blue_Laser2_Colli_First_Player  ;The Barrier is Behind the player (if player is collided with the barrier we won't fire )
		mov ax,X_BARRIER2                   ;when reached here, it means that the Barrier Will block my way. But is it the first thing to block ?
		ADD ax,BARRIER_HORIZONTAL_SIZE
		cmp ax,bx							
		JL Blue_Laser2_Colli_First_Player  ;if this new AX(X_Barrier) > BX ---> Then it's not the first thing to Block my way

		mov bx,ax





		;check the BLUE player

		Blue_Laser2_Colli_First_Player:
		mov dx,Second_player_Y
		add dx,Player_Shooter_Y_Offset ;now the dx has the BLUE Laser Start Y
		add dx,LASER_SIZE                      ;dx --->the laser ending Y
		cmp dx,First_player_Y
		JL Finish_Second_Attack_Right_TO_Left    ;all the Y of the laser < starting Y of the Second Player--> No collision
		
		sub dx,LASER_SIZE					   ;now the dx has the BLUE Laser Start Y
		mov cx,First_player_Y			   
		add cx,PLAYERS_HEIGHT    ;now cx has the last Y of the Player
		cmp dx,cx
		JG Finish_Second_Attack_Right_TO_Left	;all the Y of the laser > ending Y of the Player--> No collision

		;;;;If it reached here then, there will be a collision in the Y,check for X
		mov ax, Blue_Laser_Start_X
		mov dx,First_player_X
		ADD dx,PLAYERS_WIDTH
		cmp ax,DX								;Check the Second Player Position relative to the Player
		JLE Finish_Second_Attack_Right_TO_Left  ;The Second Player is Behind the player (if player is collided with the barrier we won't fire )
		mov ax,First_player_X                   ;when reached here, it means that the Second Player Will block my way. But is it the first thing to block ?
		add ax,PLAYERS_WIDTH
		cmp ax,bx							
		JL Finish_Second_Attack_Right_TO_Left  ;if this new AX(second_player_X) > BX ---> Then it's not the first thing to Block my way

		mov bx,ax
		mov first_player_Freeze,25				;make the first player freeze




Finish_Second_Attack_Right_TO_Left:

mov Blue_Laser_End_X,bx
Call Draw_Blue_LASER_Right_TO_Left
RET
Second_Attack_Right_TO_Left ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;description
Game_over_screen PROC
                                   mov  ah,0ch                          	;this means with int 10h ---> you're drawing a pixel
	                                 mov  di,0
	                                 mov  al,img[DI]                       	;the pixel color
	                                 mov  bh,0                            	;the page number
	                                 mov  cx,x_position               	;the starting x-position (column)
	                                 add  cx,imgW                	;as we draw in the reversed order
	                                 mov  dx,y_position               	;the starting y-position (row)
	                                 add  dx,imgH               	;as we draw in the reversed order
	;here we loop for the image size (player_size)
	fill_over:                         
	                                 cmp  al,16
	                                 jz   pass_the_pixel_over
	                                 int  10h
	pass_the_pixel_over:                  
	                                 inc  di
	                                 mov  al,img[DI]
	                                 dec  cx
	                                 cmp  cx,x_position
	                                 jnz  fill_over                        	;if not zero so we continue to the same row
	                                 mov  cx,x_position               	;the starting x-position (column)
	                                 add  cx,imgw                	;as we draw in the reversed order
	                                 dec  dx                              	;if not zero so we continue to draw the background
	                                 cmp  dx,y_position
	                                 jnz  fill_over
    ret
Game_over_screen ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;This function is to take Players name Before entering the game
Take_User_Data PROC FAR
	
    Start:
	
                            CALL  FAR PTR CLEAR_SCREEN  ;clear the screen before taking the names
	
	
	
                            mov ah,0
	
                            mov al,02
	
                            int 10h     ;this to choose text mode
	
	
                            mov ah,2        
	
                            mov dx,0a0ah
	
                            int 10h                ;Position the Cursor
                            
                             ;PRINT_Messages Name_Message_1 
                            Add DH,2                                                
                            INT 10H

                          
                            PRINT_Messages Name_Message_1   ;This MACRO will print a message to ask players to enter their names
	
                            Add DH,2                                                
                            INT 10H                                                        ;Position the Cursor below it by two rows
	
                            
	
                            Take_First_name:                                ;Start taking the first name untill it reaches the maximum/or the player presses enter
	
	
	
                                                            mov AH,0AH
                                                            mov dx,offset First_Player_Name
                                                            int 21h

                                                            CMP First_Player_Name[2],65
                                                            JGE GREATER_Than_65
                                                            JL Wrong_start
                                                            GREATER_Than_65:
                                                            CMP First_Player_Name[2],90
                                                            JLE Between_65_90_or_97_122
                                                            JG Greater_than_90
                                                            

Greater_than_90:
                                                            CMP First_Player_Name[2],97
                                                            JGE GREATER_Than_97
                                                            JL Wrong_start
                                                            GREATER_Than_97:
                                                            CMP First_Player_Name[2],122
                                                            JLE Between_65_90_or_97_122
                                                            JG Wrong_start                                                    
	
	Wrong_start:
                           
                         
                            mov ah,2        
                            mov dx,1620h
                            int 10h                ;Position the Cursor
                            PRINT_Messages Invalid_Start_msg2
                            ;;;;;delay;;;;;;
                                mov cx, 25h      ;HIGH WORD.
                                mov dx, 2420h ;LOW WORD.
                                mov ah, 86h    ;WAIT.
                                int 15h

                            Jmp Start 
	Between_65_90_or_97_122:
				
				MOV AH,2   ;MOVE CURSOR TO PRINT WAITING MESSAGE
				MOV DX,140fH
				int 10h

				mov ah,9
				mov dx,offset WAITING_MESSAGE
				int 21h
				mov di,offset First_Player_Name
				mov si ,offset Second_Player_Name
				mov cl, First_Player_Name[1]     ;actual size

;;;;;;;;;;;;;;;;;;;;;; SEND THE ACUTUAL SIZE OF PLAYER NAME
				 mov dx,3fdh

				;wait till we are able to send
				WAIT_FOR_SEND:
				in al,dx
				test al,00100000b
				jz WAIT_FOR_SEND        

			;WE CAN SEND NOW
				mov dx,3f8h
				mov al,cl
				out dx,al                                                    

;;;;;;;;;;;;;	RECEIVE THE ACUTUAL SIZE OF PLAYER NAME
                CHECK_size_AGAIN:
				mov dx,3fdh
				in al,dx
				test al,1
				jz CHECK_size_AGAIN  ;if nothing received go to the begining
				
				;if received
				mov dx,03f8h
				in al,dx
				mov ch,al
				
		add di,2
		add si,2
;;;;;;;;;;;;;;;;;;;;; SEND AND RECEIVE THE PLAYER NAMES ;;;;;
	START_NAME_SEND_REC:
	
        mov dx,3fdh
        ;wait till we are able to send
        in al,dx
        test al,00100000b
        jz CHECK_AGAIN_SR        
        
        cmp cl,0
        je reso
        ;when we are able send
        mov dx,3f8h
        mov al,[di]
        out dx,al
        inc di
        dec cl

        reso:
        mov dx,3fdh
        in al,dx
        test al,1
        jz CHECK_AGAIN_SR  ;if nothing received go to the begining
        
        ;if received
        mov dx,03f8h
        in al,dx
                
        mov [si],al
        inc si
        dec ch

        CHECK_AGAIN_SR:;check if we finished and if not go to the begining
        cmp cl,0
        jnz START_NAME_SEND_REC

        cmp ch,0
        jnz START_NAME_SEND_REC

	;;;;;;;;;;;;;;;;;;;;;;;;;;; MAIN MENU ENDED -> GO TO MENUBAR ;;;;;;;;;
	;; CLEAR SCREEN ;;
        mov ah,0                          
        mov al,3       
        int 10h

;;;;;;;SET CURSOR POSITION AND PRINT PLAY_AGAINST MESSAGE        
        mov ah,2        
        mov dx,0a04h
        int 10h  

        mov ah,9
        mov dx,offset play_against_meg 
        int 21h
;;;;;;;SET CURSOR POSITION AND PRINT PLAYER NAME MESSAGE 
        mov ah,2        
        mov dx,0a1Ch
        int 10h

        mov ah,9
        mov dx,offset Second_Player_Name+1
        int 21h

	;--------- DELAY FOR 5 SECOND  ----------------
		    mov cx, 50h      ;HIGH WORD.
            mov dx, 4840h ;LOW WORD.
            mov ah, 86h    ;WAIT.
            int 15h

Temp_End:

                                    RET
Take_User_Data ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


Main_menu PROC FAR

				FIRST_MENU:
					mov ah,00
					mov al,02
					int 10h

					mov ah,2
					mov dx,0a13h
					int 10h
					
					PRINT_Messages CHAT
					ADD DH,2
					INT 10h
					PRINT_Messages Sky_GAME
					ADD DH,2
					INT 10h
					PRINT_Messages END_GAME_mess
					
		;;;;;;;;;;;; DRAW LINE  ;;;;;;;;;;;;;
				mov ah,02
				mov dx, 1600h
				int 10h

				MOV AH,09H
				MOV AL,'-'
				MOV BH,0
				MOV BL,02
				MOV CX ,80
				INT 10H

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  CHECK FOR INVITATIONS ;;;;;;;;;;;;;
			CHECK_INVITATION:
				mov dx,3fdh  
        		in al,dx
        		test al,1
				jz CHECK_INVITAT_again
				jmp if_receive
				; CHECK_INVITAT_again:
				; 	mov ah,1
     			;     int 16h
      			; 	jz CHECK_INVITATION
				if_receive:
					mov dx,03f8h
					in al,dx
					cmp AL,3BH    ;CHECK IF F1 PRESSED CHAT INVENTATION
					jE FAR PTR GO_CHAT_INVET_REC
					CMP Al,3CH   ;CHECK IF F2 PRESSED GAME INVENTATION
					JE FAR PTR  GO_GAME_INVENT_REC_TEMP
					;CMP AH,01
					;JE End_Game

					CHECK_INVITAT_again:
					mov ah,1
     			    int 16h
      				jz CHECK_INVITATION

	;;;;;;;;;;;;;;;;;; SEND INVITAION ;;;;;;;;;;;;;;;;;;
			MOV AH,0
			INT 16h
			CMP AH,3BH  ;f1
			JE  GO_CHAT_INVET_SEND
			CMP AH,3CH   ;f2
			JE 	GO_GAME_INVENT_SEND_TEMP	
			;CMP AH,01
			;JE End_Game
			JMP CHECK_INVITATION

	;;;;;;;;;;;;;;;;;;; IF JUMP TO GO_CHAT_INVET_SEND  ;;;;;;;;;;;;		
		GO_CHAT_INVET_SEND:
			;;;;; MOVE THE CURSOR TO THE POSITION IN WHICH SENT INVETATION APPEAR
			CALL FAR PTR CHAT_INVET_PROC
		
			JMP CHECK_INVITATION
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;;;;;;;	IF I RECEIVE A CHAT INVITAION ;;;;;;;
GO_GAME_INVENT_SEND_TEMP:
JMP GO_GAME_INVENT_SEND
GO_GAME_INVENT_REC_TEMP:
JMP GO_GAME_INVENT_REC
Start_Game_temp:
jmp Start_Game		

GO_CHAT_INVET_REC:

		cmp CHAT_MASTER,1
		   jE ACCEPT
		   MOV  ah,02  ;;SLAVE
		   mov dx, 1800h
			int 10h

			MOV AH,09H
			MOV AL,' '
			MOV BH,0
			MOV BL,02
			MOV CX ,80
			INT 10H

			MOV AH,02
			MOV DX,1800H
			INT 10H
        
        
        PRINT_Messages Second_Player_Name+1
      
		ADD DL,2
    
        PRINT_Messages CHAT_INVITATION_REC_MEG
       MOV CHAT_SLAVE,1
	   MOV GAME_SLAVE,0
        jmp CHECK_INVITAT_again
        

        ACCEPT:
		mov dx,3fdh
        loop_until_ready_2:
        in al,dx
        test al,00100000b
        jz loop_until_ready_2        
;;;;;;;;;;; now we can send  ;;;;;;;;;;;;;;;;;;
        mov dx,3f8h
        mov al,3BH
        out dx,al
        jmp chatpage			
;----------------------------------------------------;


GO_GAME_INVENT_SEND:	
		;;;;;;;; CLEAR THE LINE 23 BEFORE PRINTING THE NEXT INVITATION MSG ;;;;;;;
		;;; MOVE THE CURSOR TO WRITE
		cmp GAME_SLAVE,1  ;
		JE receive_level
		

		mov ah,02
		mov dx, 1700h
		int 10h

		MOV AH,09H
		MOV AL,' '
		MOV BH,0
		MOV BL,02
		MOV CX ,80
		INT 10H

		MOV AH,02
		MOV DX , 1700H
		INT 10H
		PRINT_Messages GAME_INVITATION_SEND_MSG

		add dl,2

		PRINT_Messages Second_Player_Name




	;;;; CHECK IF REGISTER IS EMPTY ;;;
	MOV DX,3fdh
	loop_until_ready_3:
 	in al,dx
    test al,00100000b
    jz loop_until_ready_3 	

	;when we are able send
    mov dx,3f8h
    mov al,3CH  ;F2 ->GAME
    out dx,al
	mov GAME_MASTER,1
	MOV CHAT_MASTER,0

	JMP CHECK_INVITATION

	receive_level:
		
		MOV DX,3fdh
		loop_until_ready_33:
		in al,dx
		test al,00100000b
		jz loop_until_ready_33 	

		;when we are able send
		mov dx,3f8h
		mov al,3CH
		out dx,al

		call far ptr CLEAR_SCREEN
		call far ptr draw_background
		CALL FAR PTR draw_p1
		CALL FAR PTR draw_p2
		

		MOV DX,3fdh
		loop_until_ready_34:
		in al,dx
		test al,1
		jz loop_until_ready_34 	

		;when we are able send
		mov dx,3f8h
		in al,dx
		mov level,al
		
		jmp LETS_START_GAME



	
;--------------------------------------------------------;
GO_GAME_INVENT_REC:
	CMP GAME_MASTER,1
	JE ACCEPT_GAME
		mov game_slave,1
		MOV CHAT_SLAVE,0

		MOV  ah,02
		mov dx, 1800h
		int 10h

		MOV AH,09H
		MOV AL,' '
		MOV BH,0
		MOV BL,02
		MOV CX ,80
		INT 10H

		MOV AH,02
		MOV DX,1800H
		INT 10H
        
        mov ah,9
        mov dx,offset Second_Player_Name+1
        int 21h

        mov ah,9
        mov dx,offset GAME_INVITATION_REC_MSG
        int 21h
        jmp CHECK_INVITAT_again

	ACCEPT_GAME:
; 		mov dx,3fdh
;         loop_until_ready_25:
;         in al,dx
;         test al,00100000b
;         jz loop_until_ready_25        
; ;;;;;;;;;;; now we can send  ;;;;;;;;;;;;;;;;;;
;         mov dx,3f8h
; 		mov al,3CH
;         out dx,al

		JMP Which_level
		ABCD:
		mov dx,3fdh
        loop_until_ready_5:
        in al,dx
        test al,00100000b
        jz loop_until_ready_5        
;;;;;;;;;;; now we can send  ;;;;;;;;;;;;;;;;;;
        mov dx,3f8h
		mov al,bl
        out dx,al
		mov level,bl
		LETS_START_GAME:
        
		CALL FAR PTR Start_Game
		jmp First_menu



					chatpage:
						CALL FAR PTR CHAT_MODULE
						

					Which_level:
                                   mov ah,00
                                    mov al,02
                                    int 10h
                                    mov ah,2
                                    mov dx,01113h
                                    int 10h
                                    PRINT_Messages levelone
                                     ADD DH,2
                                    INT 10h
                                    PRINT_Messages leveltwo

                                    mov ah,0
                                    int 16h
									cmp al,49
									mov bl ,al
									JE ABCD
									cmp al,50
									mov bl ,al
									JE ABCD
									JMP Which_level
				
								

					End_Game :
							RET
Main_menu ENDP

chose_which_level proc FAR

RET
chose_which_level ENDP

CHAT_INVET_PROC PROC FAR
			mov ah,02
			mov dx, 1700h
			int 10h
			MOV AH,09H
			MOV AL,' '
			MOV BH,0
			MOV BL,02
			MOV CX ,80
			INT 10H

			MOV AH,02
			MOV DX,1700H
			INT 10H

			PRINT_Messages CHAT_INVITATION_SEND_MEG

			ADD DL,2

		
        	PRINT_Messages Second_Player_Name+1
        	

        	mov dx,3fdh

        	loop_until_ready:
        	in al,dx
        	test al,00100000b
        	jz loop_until_ready        
        
;;;;;;;;;;; now we can send  ;;;;;;;;;;;;;;;;;;
         	mov dx,3f8h
        	mov al,3BH   ;F1 ->CHAT
        	out dx,al
			mov GAME_MASTER,0
			MOV CHAT_MASTER,1  ;;;THE PLAYER HOW SENT THE CHAT INVITAION IS THE 

RET
CHAT_INVET_PROC ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Start_Game PROC FAR

				CALL FAR PTR CLEAR_SCREEN ;clear the screen before entering the game
				call FAR PTR draw_background ;draw the background of the Game window
				call FAR PTR draw_h1
				call FAR PTR draw_h2
				CALL FAR PTR draw_p1
				CALL FAR PTR draw_p2
				call FAR PTR DRAW_BARRIER1
				call FAR PTR DRAW_BARRIER2

			;;;;;;;;;;;GAME LOOP FUNCTIONS;;;;;;;;;;;;;;;;;;;;;;;;;;;
				CHECK_TIME:       

							MOV  AH,2Ch                          	;get the system time
							INT  21h                             	;CH = hour CL = minute DH = second DL = 1/100 seconds
							CMP  DL,TIME_AUX                     	;is the current time equal to the previous one(TIME_AUX)?
							JE   CHECK_TIME                      	;if it is the same, check again
							;if it's different, then draw, move, etc.
							MOV  TIME_AUX,DL                         ;update time

							cmp level,49    
							JZ level1
							
							level2:
							CALL FAR PTR MOVE_BARRIERS_2

							level1:                
							CALL FAR PTR MOVE_BARRIERS
							

							;check if health is zero, Game Over
							mov ax,first_player_health
							cmp ax,0
							jz Game_Over

							;check if health is zero, Game Over
							mov ax,second_player_health
							cmp ax,0
							jz Game_Over

							CALL FAR PTR MOVE_PLAYERS
							
							;;;;;;;;;;;;;Flushing the keyboard buffer
							mov ah,0ch
							mov al,0
							int 21h												
					JMP  CHECK_TIME                      	;after everything checks time again		

			;;;;;;;;;;;GAME ENDING FUNCTIONS;;;;;;;;;;;;;;;;;;;;;;;;;;;
				Game_Over: 
				CALL FAR PTR CLEAR_SCREEN ;clear the screen before entering the game
				; call FAR PTR draw_background
				call far PTR Game_over_screen
					mov ax,second_player_health
				cmp ax,0
				jz first_wins
				mov ax,first_player_health
				cmp ax,0
				jz second_wins
				jmp final
					first_wins:
					mov first_player_X,30 
					mov first_player_y,90
					call FAR PTR draw_p1
					MOV BP, OFFSET first_player_wins ; ES: BP POINTS TO THE TEXT
					MOV AH, 13H ; WRITE THE STRING
					MOV AL, 01H; ATTRIBUTE IN BL, MOVE CURSOR TO THAT POSITION
					XOR BH,BH ; VIDEO PAGE = 0
					MOV BL, 0eh ;YELLOW
					MOV CX, 17 ; LENGTH OF THE STRING
					MOV DH, 12 ;ROW TO PLACE STRING
					MOV DL, 12 ; COLUMN TO PLACE STRING
					INT 10H
					jmp final
					second_wins:
					mov second_player_X,30
					mov second_player_Y,90
					call FAR PTR draw_p2
					MOV BP, OFFSET second_player_wins ; ES: BP POINTS TO THE TEXT
					MOV AH, 13H ; WRITE THE STRING
					MOV AL, 01H; ATTRIBUTE IN BL, MOVE CURSOR TO THAT POSITION
					XOR BH,BH ; VIDEO PAGE = 0
					MOV BL, 01h ;BLUE
					MOV CX, 20 ; LENGTH OF THE STRING
					MOV DH, 12 ;ROW TO PLACE STRING
					MOV DL, 12 ; COLUMN TO PLACE STRING
					INT 10H

				final:
                mov ah,2        
                mov dx,1100h
                int 10h                ;Position the Cursor
				ADD DH,3
				PRINT_Messages GAME_OVER_mess
				mov ah,0
				int 16h
				cmp AH,01
				JNE Final

	RET
Start_Game ENDP



  CHAT_MODULE PROC FAR
	;CLEAR screen
	                    mov  ah,0
	                    mov  al,3
	                    int  10h

	                    CALL FAR PTR SET_CHATTERS
	                    call FAR PTR draw_line

	;set first cursor position to top left center
	                    MOV  AH,2
	                    MOV  DL,0
	                    MOV  DH ,0
	                    INT  10H



	;check if any letter recevied
	CHECK_RECEIVE:      
	;check if their is letter received
	                    MOV  DX,Line_status_register         	; LINE STATUS resgister
	                    IN   AL,DX
	                    TEST AL,1
	                    JZ   NO_RECIEVE

	;receive register
	                    MOV  DX ,TRANSMIT_DATA_REGISTER
	                    IN   AL ,DX
	                    MOV  LETTER_RECEIVING,AL

	                    CMP  AL,1BH                          	;scan code of ESC
	                    JE   END_CHAT
						   
	                    CMP  AL,8   
				 		JZ  IT_IS_BACK_REC                     	;CHECK IF RECIEVED BACKSPACE TO SET THE VARIABLE
						JMP CHECK_ENTER_REC
			IT_IS_BACK_REC:
	                    MOV  IS_BACKSPACE,1
	                    JMP  GO_TO_LOWER_SCREEN

	CHECK_ENTER_REC:   CMP  AL,13                           	;CHECK IF RECIEVED ENTER
	                    JZ   ITIS_ENTER
	                    JMP  GO_TO_LOWER_SCREEN
	ITIS_ENTER:         
	                    MOV  IS_ENTER,1

	GO_TO_LOWER_SCREEN: CALL FAR PTR Lower_screen
	                    JMP  CHECK_RECEIVE


	;IF NOTHING TO RECIEVE SEND CHARACTER IF ANY
	NO_RECIEVE:         
	                    MOV  AL,0
	                    MOV  AH,01H
	                    INT  16H                             	

	                    CMP  AL,0
	                    JE   CHECK_RECEIVE                   	

	                    MOV  AH,00H                          	
	                    INT  16H
	                    MOV  LETTER_SENT,AL                  	;STORE DATA IN LETTER TO BE SENT
																;LATER


	;--------------------- START SENDING -------------------------
	                    MOV  DX , Line_status_register       	;LINE STATUS REGISTER
	                    IN   AL , DX                         	;READ LINE STATUS
	                    TEST AL , 00100000B
	                    JZ   CHECK_RECEIVE                   	;NOT EMPTY
						   
	                    MOV  DX , TRANSMIT_DATA_REGISTER     	; TRANSMIT DATA REGISTER
	                    MOV  AL,LETTER_SENT
	                    OUT  DX , AL

	                    CMP  AL,27                           	; check if ESC is pressed
	                    JE   END_CHAT

	                    CMP  AL,8
						JZ IT_IS_BACK1
						JMP check_enter_SEND
				IT_IS_BACK1:
	                    MOV  IS_BACKSPACE,1
	                    JMP  GO_TO_UPPER_SCREEN

	check_enter_SEND:   CMP  AL,13                            ;CHECK scan code if ENTER KEY
	                    JNZ  GO_TO_UPPER_SCREEN
	                    MOV  IS_ENTER,1

	GO_TO_UPPER_SCREEN:      CALL FAR PTR upper_screen
	                    	 JMP  CHECK_RECEIVE

	END_CHAT:           
	                  
	                    mov  ah,0
	                    mov  al,3
	                    int  10h
	                    RET
CHAT_MODULE ENDP

SET_CHATTERS PROC FAR
	                    mov  ah,2                            	;SET POSITION
	                    mov  DX,0H
	                    INT  10H

	                    MOV  AH,09
	                    MOV  DX,OFFSET First_Player_Name         	;PRINT first_chatter NAME
	                    INT  21H

	                    mov  ah,2                            	;SET POSITION
	                    mov  DX,0c00H
	                    INT  10H
	                    MOV  AH,09
	                    MOV  DX,OFFSET Second_Player_Name        	;PRINT SECOND_chatter NAME
	                    INT  21H

						mov  ah,2                            	;SET POSITION
	                    mov  DX,1800H
	                    INT  10H
	                    MOV  AH,09
	                    MOV  DX,OFFSET chat_end_string        	;PRINT SECOND_chatter NAME
	                    INT  21H

	                    RET
SET_CHATTERS ENDP

	;description
draw_line PROC FAR
	                    MOV  AH,2
	                    mov  dx,12
	                    INT  10H

	                    mov  ax,0b800h                       	;text mode
	                    mov  DI,1760                         	; each row 80 column each one 2 bits 80*2*12
	                    mov  es,ax
	                    mov  ah,0fh                          	; black background
	                    mov  al,'-'                          	; '-'
	                    mov  cx,80
	                    rep  stosw

						mov  ax,0b800h                       	;text mode
	                    mov  DI,3680                         	; each row 80 column each one 2 bits 80*2*12
	                    mov  es,ax
	                    mov  ah,0fh                          	; black background
	                    mov  al,'_'                          	; '-'
	                    mov  cx,80
	                    rep  stosw
	                    ret
draw_line ENDP

upper_screen PROC FAR
	                    push ax
	                    push bx
	                    push cx
						PUSH DX
	                    CMP  IS_BACKSPACE,1
	                    JNZ  NOT_BACK
	                    CMP  First_cursor_X,start_position_x 
	                    JG  CAN_BACK
	                    JMP  SET_BACK
						
	CAN_BACK:         
	                    DEC  First_cursor_X                  ; IF IT IS BACKSPACE DEC POSITION X
															 ; AND STORE ' ' IN AL
	SET_BACK:       
	                    MOV  LETTER_SENT,' '                  	;SPACE
	                    JMP  set_new_position


	NOT_BACK:      
	                    CMP  IS_ENTER,1
	                    JE NEW_LINE 
						JMP set_new_position


	NEW_LINE:          

	                    INC  First_cursor_Y                  	;START NEW LINE
	                    MOV  First_cursor_X,start_position_x 	;SET X TO LINE BEGINNING
	                    JMP  CHECK_SCROLL            	;SCROLL ONE LINE


	set_new_position:   
	                    MOV  AH,2
	                    MOV  DL ,First_cursor_X
	                    MOV  DH ,First_cursor_Y
	                    INT  10H
      
	;	PRINT THE CURRENT CHARACTER WITH CERTAIN COLOR
	                    MOV  AH,9
	                    MOV  BH,0
	                    MOV  AL ,LETTER_SENT      ; STORE SENT LETTER IN AL
	                    MOV  CX,1H					; PRINT LETTER 1 TIME
	                    MOV  BL,03H                 ;LIGHT BLUE COLOR	
	                    INT  10H

	                    CMP  IS_BACKSPACE,1  
	                    JE   END_UPPER_CHAT
	                    INC  First_cursor_X
						
						;IF FIRST_CURSOR_X REACHES END OF LINE 76 START NEW LINE
						MOV DL,end_line
	                    CMP  First_cursor_X ,DL   
	                    JNZ  END_UPPER_CHAT
	                    JMP  NEW_LINE
	CHECK_SCROLL: 
			CMP  First_cursor_Y,11
	        JNZ  END_UPPER_CHAT
			JMP SCROLL_UPPER_SCREEN

	SCROLL_UPPER_SCREEN:
					CALL FAR PTR SCROLL_UP  
	                   

	END_UPPER_CHAT:  

	                    MOV  AH,2
	                    MOV  DL ,First_cursor_X     ; SET NEW X-POSITION OF CURSOR
	                    MOV  DH ,First_cursor_Y		 ; SET NEW Y-POSITION OF CURSOR
	                    INT  10H

						MOV  AL,0

	                    MOV  IS_BACKSPACE,0      ;RETURN IS_BACKSPACE,IS_ENTER TO ZERO AGAIN
	                    MOV  IS_ENTER,0
	                    

						POP DX
	                    pop  cx
	                    pop  bx
	                    pop  ax
	                    RET
upper_screen ENDP

;description
;description
SCROLL_UP PROC FAR
	PUSH ax
	PUSH bx
	PUSH cx
	PUSH DX

   MOV  AH,6
	MOV  AL,1                            	; SCROLL THE UPPER PART  BY 1 LINE
	MOV  BH,0                            	; NORMAL VIDEO ATTRIBUTE
	MOV  CH,1                            	;GET POSITION
	MOV  CL,03      				 
	MOV  DH,10
	MOV  DL,79
	INT  10H
	DEC  First_cursor_Y	

	POP dx
	POP CX
	POP BX 
	POP AX
	RET 
SCROLL_UP ENDP

Lower_screen PROC
						PUSH AX
						PUSH bx
						PUSH cx
						PUSH DX

	                    CMP  IS_BACKSPACE,1
	                    JNZ  NOT_BACK2
	                    CMP  SECOND_CURSOR_X,start_position_x
	                    JG  CAN_BACK2
	                    JMP  SET_BACK2

	            
	CAN_BACK2:        
	                    DEC  SECOND_CURSOR_X

	SET_BACK2:      
	                    MOV  AL,' '                           	;SPACE
	                    JMP  set_new_position2

						   
	NOT_BACK2:     
	                    CMP  IS_ENTER,1
						JE NEW_LINE2
	                    JMP  set_new_position2



	NEW_LINE2:         

	                    INC  SECOND_CURSOR_Y
	                    MOV  SECOND_CURSOR_X,start_position_x   ;SET CURSOR_X OF LOWER SCREEN 
	                    JMP  CHECK_SCROLL2			   
	set_new_position2:  

	                    MOV  AH,2
	                    MOV  DL ,SECOND_CURSOR_X ; SET CURSOR POSITION OF 2ND CURSOR
	                    MOV  DH ,SECOND_CURSOR_Y
	                    INT  10H
	

	                    MOV  AH,9                ;PRINT THE RECEIVED LETTER WITH RED COLOR
	                    MOV  BH,0				 
	                    MOV  CX,1H				; one time
	                    MOV  BL,0CH				;RED COLOR
	                    INT  10H
						

	
	                    CMP  IS_BACKSPACE,1
	                    JE   END_LOWER_CHAT
	                    INC  SECOND_CURSOR_X    ; inc X_position of 2nd cursor if it is not backspace
						   
						mov dl,end_line
	                    CMP  SECOND_CURSOR_X ,dl ; if X_position of 2nd cursor reach end of line 
	                    JNE  END_LOWER_CHAT		 
	                    JMP  NEW_LINE2			; start new line	
	CHECK_SCROLL2:
	  				CMP  SECOND_CURSOR_Y,23
	                JNE  END_LOWER_CHAT
					JMP  SCROLL_BOTTOM
	SCROLL_BOTTOM:      
	                CALL FAR PTR SCROLL_DOWN
	                    

	END_LOWER_CHAT: 

	                    MOV  AH,2
	                    MOV  DL ,First_cursor_X	 ;SET NEW CURSOR POSITION X
	                    MOV  DH ,First_cursor_Y  ;SET NEW CURSOR POSITION Y
	                    INT  10H
						   
	;CLEAR FLAGS
	                    MOV  IS_ENTER,0
	                    MOV  IS_BACKSPACE,0
	                    MOV  AL,0

						POP dx
						POP CX
						POP bx
						POP ax

	                    RET
Lower_screen ENDP
 
;description
SCROLL_dOWN PROC FAR
		PUSH ax
		PUSH bx
		PUSH cx
		PUSH DX

	    MOV  AH,6
	    MOV  AL,1
	    MOV  BH,0
	    MOV  CH,13
	    MOV  CL,0
	    MOV  DH,22
	    MOV  DL,79
	    INT  10H
	    DEC  SECOND_CURSOR_Y

		POP dx
		POP CX
		POP BX 
		POP AX
	RET 
SCROLL_dOWN ENDP





start_in_game_chatting proc FAR
start_in_game_chatting_again:

	print_first_name_in_game_chat:

    mov SI, OFFSET First_Player_Name
	inc SI
	mov cx,0
	mov cl,First_Player_Name+1
	inc SI
	mov  dl, 0   ;Column (0->39)
	mov  dh, 21   ;Row (0-> 24) and we're only printing in the 1/5 of the screen
	mov  bh, 0    ;Display page

    print_first_name_in_game_chat_loop :
	
	mov  ah, 02h  ;SetCursorPosition
	int  10h
	mov  al, [SI]
	mov  bl, 0Ch  ;Color is red
	mov  bh, 0    ;Display page
	mov  ah, 0Eh  ;Teletype
	int  10h
	INC SI ;the next char
	INC DL ;increase col
	inc in_game_cursor_up
	Loop print_first_name_in_game_chat_loop
	
	
	;if x=79  and erase all and print name again
	;print chars from keyboard
	;if  enter pressed  then erase backward all and prnit name agaibn 
	;send the character 

	;print name2 in pos 22;
	print_second_name_in_game_chat:

    mov SI, OFFSET Second_Player_Name
	inc SI
	mov cx,0
	mov cl,Second_Player_Name+1
	inc SI
	mov  dl, 0   ;Column (0->39)
	mov  dh, 22   ;Row (0-> 24) and we're only printing in the 1/5 of the screen
	mov  bh, 0    ;Display page

    print_second_name_in_game_chat_loop :
	
	mov  ah, 02h  ;SetCursorPosition
	int  10h
	mov  al, [SI]
	mov  bl, 0Ch  ;Color is red
	mov  bh, 0    ;Display page
	mov  ah, 0Eh  ;Teletype
	int  10h
	INC SI ;the next char
	INC DL ;increase col
	inc in_game_cursor_down 
	Loop print_second_name_in_game_chat_loop
	
	WHILE_IN_GAME_CHAT:

		read_keyboard_ingame:
		mov ah,1
		int 16h
		jz recevive_vale_from_another_player  ;; if no key pressed then see incoming chars
		mov ah,0 
		int 16h 
		mov in_game_to_send_val,al
		cmp ah,3eh;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; if key is f4 then get isquit be 1
		jne not_quit
		mov is_quit, 1
		mov in_game_to_send_val,ah  ;; put the vakue of the scan code instead of ascii code as f4 has no ascii

		not_quit:
		cmp in_game_to_send_val,';'   ; if user press ';'  then he wil continue the game
		jne not_out_out_chat
		mov in_game_end_chat,1d 
		not_out_out_chat:


		;;send value to next player 
		mov dx , 3FDH ; Line Status Register
		AGAIN_in_game_chat: In al , dx ;Read Line Status
		test al , 00100000b
		JZ AGAIN_in_game_chat ;Not empty
		;If empty put the VALUE in Transmit data register
		mov dx , 3F8H ; Transmit data register
		mov al,in_game_to_send_val
		out dx , al

		cmp in_game_cursor_up,79  
		jne not_end_of_line
		;; clear_line_in_game_chat as the cursor has reached its end so we erase from the end of the postion of the player name to position 79
			 mov di, offset First_Player_Name
			 inc di  
			 mov in_game_iterator ,[di]    ; save in the iterator the size of the player name to begin after it
			 inc in_game_iterator


			clear_line_in_game_chat_up:
			
			mov  dl, in_game_iterator   ;Column
			mov  dh, 21   ;Row
			mov  bh, 0    ;Display page
			mov  ah, 02h  ;SetCursorPosition
			int  10h

			mov  al, ' '
			mov  bl, 0h  ;Color is black
			mov  bh, 0    ;Display page
			mov  ah, 0Eh  ;Teletype
			int  10h

			inc in_game_iterator
			mov al,in_game_iterator
			cmp al,79d
			jle clear_line_in_game_chat_up
		not_end_of_line:
		mov  dl, in_game_cursor_up   ;Column
			mov  dh, 21   ;Row
			mov  bh, 0    ;Display page
			mov  ah, 02h  ;SetCursorPosition
			int  10h

			mov  al, in_game_to_send_val
			mov  bl, 0Fh  ;Color is white
			mov  bh, 0    ;Display page
			mov  ah, 0Eh  ;Teletype
			int  10h
			inc in_game_cursor_up

		recevive_vale_from_another_player:
		mov dx , 3FDH ; Line Status Register
		in al , dx
		test al , 1
		JZ chk_end ;Not Ready
		;If Ready read the VALUE in Receive data register
		mov dx , 03F8H
		in al , dx
		mov in_game_received_val , al
		cmp al,3eh   ;;;;;; if the value recieced equals to f4 then end the game 
		jne not_end_game2
		mov is_quit,1d
		not_end_game2:
		cmp al,';'          ;if value received is ';' then return back to the game
		jne not_end_chat2
		mov is_quit,1
		not_end_chat2:

    	print_from_another_player:

		cmp in_game_cursor_down,79    ;; same as before we clear the line if it reached its end
		jne not_end_of_line2 
		mov di, offset Second_Player_Name
		inc di

		 mov in_game_iterator ,[di]
			 inc in_game_iterator


			clear_line_in_game_chat_down:
			
			mov  dl, in_game_iterator   ;Column
			mov  dh, 22   ;Row
			mov  bh, 0    ;Display page
			mov  ah, 02h  ;SetCursorPosition
			int  10h

			mov  al, ' '
			mov  bl, 0h  ;Color is black
			mov  bh, 0    ;Display page
			mov  ah, 0Eh  ;Teletype
			int  10h

			inc in_game_iterator
			mov al,in_game_iterator
			cmp al,79d
			jle clear_line_in_game_chat_down

			
			

		not_end_of_line2:

		mov  dl, in_game_cursor_down   ;Column
			mov  dh, 22   ;Row
			mov  bh, 0    ;Display page
			mov  ah, 02h  ;SetCursorPosition
			int  10h

			mov  al, in_game_received_val
			mov  bl, 0Fh  ;Color is white
			mov  bh, 0    ;Display page
			mov  ah, 0Eh  ;Teletype
			int  10h
			inc in_game_cursor_down

		chk_end:

		cmp in_game_end_chat,1
		je  return_from_ingame_chat
		cmp is_quit,1
		je  return_from_ingame_chat
		jmp WHILE_IN_GAME_CHAT


		return_from_ingame_chat:


		mov in_game_end_chat,0
		mov in_game_cursor_up,0
		mov in_game_cursor_down,0
		mov in_game_iterator,0 
		
		;; clearing chat lines before returning from the functoin 
		clear_line_in_game_chat_down2:
			
			mov  dl, in_game_iterator   ;Column
			mov  dh, 22   ;Row
			mov  bh, 0    ;Display page
			mov  ah, 02h  ;SetCursorPosition
			int  10h

			mov  al, ' '
			mov  bl, 0h  ;Color is black
			mov  bh, 0    ;Display page
			mov  ah, 0Eh  ;Teletype
			int  10h

			inc in_game_iterator
			mov al,in_game_iterator
			cmp al,79d
			jle clear_line_in_game_chat_down2
		
		mov in_game_iterator,0


		clear_line_in_game_chat_up2:
			
			mov  dl, in_game_iterator   ;Column
			mov  dh, 21   ;Row
			mov  bh, 0    ;Display page
			mov  ah, 02h  ;SetCursorPosition
			int  10h

			mov  al, ' '
			mov  bl, 0h  ;Color is black
			mov  bh, 0    ;Display page
			mov  ah, 0Eh  ;Teletype
			int  10h

			inc in_game_iterator
			mov al,in_game_iterator
			cmp al,79d
			jle clear_line_in_game_chat_up2
		not_end_of_line:
		
		mov in_game_iterator,0

		ret



	;if x=79 erase all backward and print name 
	;if recevived print character 
	;if enter rceived erase backwards ;if x=79  erase all and print name again



RET
start_in_game_chatting ENDP



END MAIN